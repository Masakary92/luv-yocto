<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[<!ENTITY % poky SYSTEM "../poky.ent"> %poky; ] >

<chapter id=' concepts-manual-concepts'>
<title>Yocto Project Concepts</title>

    <section id='yocto-project-components'>
        <title>Yocto Project Components</title>

        <para>
            The
            <ulink url='&YOCTO_DOCS_REF_URL;#bitbake-term'>BitBake</ulink>
            task executor together with various types of configuration files
            form the OpenEmbedded Core.
            This section overviews these components by describing their use and
            how they interact.
        </para>

        <para>
            BitBake handles the parsing and execution of the data files.
            The data itself is of various types:
            <itemizedlist>
                <listitem><para>
                    <emphasis>Recipes:</emphasis>
                    Provides details about particular pieces of software.
                    </para></listitem>
                <listitem><para>
                    <emphasis>Class Data:</emphasis>
                    Abstracts common build information (e.g. how to build a
                    Linux kernel).
                    </para></listitem>
                <listitem><para>
                    <emphasis>Configuration Data:</emphasis>
                    Defines machine-specific settings, policy decisions, and
                    so forth.
                    Configuration data acts as the glue to bind everything
                    together.
                    </para></listitem>
            </itemizedlist>
        </para>

        <para>
            BitBake knows how to combine multiple data sources together and
            refers to each data source as a layer.
            For information on layers, see the
            "<ulink url='&YOCTO_DOCS_DEV_URL;#understanding-and-creating-layers'>Understanding and Creating Layers</ulink>"
            section of the Yocto Project Development Tasks Manual.
        </para>

        <para>
            Following are some brief details on these core components.
            For additional information on how these components interact during
            a build, see the
            "<link linkend='development-concepts'>Development Concepts</link>"
            section.
        </para>

        <section id='usingpoky-components-bitbake'>
            <title>BitBake</title>

            <para>
                BitBake is the tool at the heart of the
                <ulink url='&YOCTO_DOCS_REF_URL;#build-system-term'>OpenEmbedded build system</ulink>
                and is responsible for parsing the
                <ulink url='&YOCTO_DOCS_REF_URL;#metadata'>Metadata</ulink>,
                generating a list of tasks from it, and then executing those
                tasks.
            </para>

            <para>
                This section briefly introduces BitBake.
                If you want more information on BitBake, see the
                <ulink url='&YOCTO_DOCS_BB_URL;#bitbake-user-manual'>BitBake User Manual</ulink>.
            </para>

            <para>
                To see a list of the options BitBake supports, use either of
                the following commands:
                <literallayout class='monospaced'>
     $ bitbake -h
     $ bitbake --help
                </literallayout>
            </para>

            <para>
                The most common usage for BitBake is
                <filename>bitbake <replaceable>packagename</replaceable></filename>,
                where <filename>packagename</filename> is the name of the
                package you want to build (referred to as the "target").
                The target often equates to the first part of a recipe's
                filename (e.g. "foo" for a recipe named
                <filename>foo_1.3.0-r0.bb</filename>).
                So, to process the
                <filename>matchbox-desktop_1.2.3.bb</filename> recipe file, you
                might type the following:
                <literallayout class='monospaced'>
     $ bitbake matchbox-desktop
                </literallayout>
                Several different versions of
                <filename>matchbox-desktop</filename> might exist.
                BitBake chooses the one selected by the distribution
                configuration.
                You can get more details about how BitBake chooses between
                different target versions and providers in the
                "<ulink url='&YOCTO_DOCS_BB_URL;#bb-bitbake-preferences'>Preferences</ulink>"
                section of the BitBake User Manual.
            </para>

            <para>
                BitBake also tries to execute any dependent tasks first.
                So for example, before building
                <filename>matchbox-desktop</filename>, BitBake would build a
                cross compiler and <filename>glibc</filename> if they had not
                already been built.
            </para>

            <para>
                A useful BitBake option to consider is the
                <filename>-k</filename> or <filename>--continue</filename>
                option.
                This option instructs BitBake to try and continue processing
                the job as long as possible even after encountering an error.
                When an error occurs, the target that failed and those that
                depend on it cannot be remade.
                However, when you use this option other dependencies can
                still be processed.
            </para>
        </section>

        <section id='concepts-components-metadata'>
            <title>Metadata (Recipes)</title>

            <para>
                Files that have the <filename>.bb</filename> suffix are
                "recipes" files.
                In general, a recipe contains information about a single piece
                of software.
                This information includes the location from which to download
                the unaltered source, any source patches to be applied to that
                source (if needed), which special configuration options to
                apply, how to compile the source files, and how to package the
                compiled output.
            </para>

            <para>
                The term "package" is sometimes used to refer to recipes.
                However, since the word "package" is used for the packaged
                output from the OpenEmbedded build system (i.e.
                <filename>.ipk</filename> or <filename>.deb</filename> files),
                this document avoids using the term "package" when referring
                to recipes.
            </para>
        </section>

        <section id='concepts-components-classes'>
            <title>Classes</title>

            <para>
                Class files (<filename>.bbclass</filename>) contain information
                that is useful to share between Metadata files.
                An example is the
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-classes-autotools'><filename>autotools</filename></ulink>
                class, which contains common settings for any application that
                Autotools uses.
                The
                "<ulink url='&YOCTO_DOCS_REF_URL;#ref-classes'>Classes</ulink>"
                chapter in the Yocto Project Reference Manual provides
                details about classes and how to use them.
            </para>
        </section>

        <section id='concepts-components-configuration'>
            <title>Configuration</title>

            <para>
                The configuration files (<filename>.conf</filename>) define
                various configuration variables that govern the OpenEmbedded
                build process.
                These files fall into several areas that define machine
                configuration options, distribution configuration options,
                compiler tuning options, general common configuration options,
                and user configuration options in
                <filename>local.conf</filename>, which is found in the
                <ulink url='&YOCTO_DOCS_REF_URL;#build-directory'>Build Directory</ulink>.
            </para>
        </section>
    </section>

    <section id='cm-layers'>
        <title>Layers</title>

        <para>
            Layers are repositories that contain related sets of instructions
            that tell the OpenEmbedded build system what to do.
            You use different layers to logically separate information in your
            build.
            You can collaborate, share, and reuse layers.
            The Layer Model simultaneously supports collaboration and
            customization.
        </para>

        <para>
            For more introductory information on the Yocto Project's layer
            model, see the
            "<ulink url='&YOCTO_DOCS_GS_URL;#the-yocto-project-layer-model'>The Yocto Project Layer Model</ulink>"
            section in the Getting Started With Yocto Project Manual.
            For procedures on how to create layers, see the
            "<ulink url='&YOCTO_DOCS_DEV_URL;#understanding-and-creating-layers'>Understanding and Creating Layers</ulink>"
            section in the Yocto Project Development Tasks Manual.
        </para>
    </section>

    <section id="development-concepts">
        <title>Development Concepts</title>

        <para>
            This section takes a more detailed look inside the build
            process used by the OpenEmbedded build system.
            The following diagram represents the build at a high level.
            The remainder of this section expands on the fundamental input,
            output, process, and
            <ulink url='&YOCTO_DOCS_REF_URL;#metadata'>Metadata</ulink>
            blocks that make up the build process.
        </para>

        <para id='general-yocto-environment-figure'>
            <imagedata fileref="figures/yocto-environment-ref.png" align="center" width="8in" depth="4.25in" />
        </para>

        <para>
            In general, the build process consists of several functional areas:
            <itemizedlist>
                <listitem><para>
                    <emphasis>User Configuration:</emphasis>
                    Metadata you can use to control the build process.
                    </para></listitem>
                <listitem><para>
                    <emphasis>Metadata Layers:</emphasis>
                    Various layers that provide software, machine, and
                    distro Metadata.
                    </para></listitem>
                <listitem><para>
                    <emphasis>Source Files:</emphasis>
                    Upstream releases, local projects, and SCMs.
                    </para></listitem>
                <listitem><para>
                    <emphasis>Build System:</emphasis>
                    Processes under the control of
                    <ulink url='&YOCTO_DOCS_REF_URL;#bitbake-term'>BitBake</ulink>.
                    This block expands on how BitBake fetches source, applies
                    patches, completes compilation, analyzes output for package
                    generation, creates and tests packages, generates images,
                    and generates cross-development tools.
                    </para></listitem>
                <listitem><para>
                    <emphasis>Package Feeds:</emphasis>
                    Directories containing output packages (RPM, DEB or IPK),
                    which are subsequently used in the construction of an
                    image or SDK, produced by the build system.
                    These feeds can also be copied and shared using a web
                    server or other means to facilitate extending or updating
                    existing images on devices at runtime if runtime package
                    management is enabled.
                    </para></listitem>
                <listitem><para>
                    <emphasis>Images:</emphasis>
                    Images produced by the development process.
                    </para></listitem>
                <listitem><para>
                    <emphasis>Application Development SDK:</emphasis>
                    Cross-development tools that are produced along with
                    an image or separately with BitBake.
                    </para></listitem>
            </itemizedlist>
        </para>

        <section id="user-configuration">
            <title>User Configuration</title>

            <para>
                User configuration helps define the build.
                Through user configuration, you can tell BitBake the
                target architecture for which you are building the image,
                where to store downloaded source, and other build properties.
            </para>

            <para>
                The following figure shows an expanded representation of the
                "User Configuration" box of the
                <link linkend='general-yocto-environment-figure'>general Build Process figure</link>:
            </para>

            <para>
                <imagedata fileref="figures/user-configuration.png" align="center" width="8in" depth="4.5in" />
            </para>

            <para>
                BitBake needs some basic configuration files in order to
                complete a build.
                These files are <filename>*.conf</filename> files.
                The minimally necessary ones reside as example files in the
                <ulink url='&YOCTO_DOCS_REF_URL;#source-directory'>Source Directory</ulink>.
                For simplicity, this section refers to the Source Directory as
                the "Poky Directory."
            </para>

            <para>
                When you clone the <filename>poky</filename> Git repository
                or you download and unpack a Yocto Project release, you
                can set up the Source Directory to be named anything you want.
                For this discussion, the cloned repository uses the default
                name <filename>poky</filename>.
                <note>
                    The
                    <ulink url='&YOCTO_DOCS_REF_URL;#poky'>Poky</ulink>
                    repository is primarily an aggregation of existing
                    repositories.
                    It is not a canonical upstream source.
                </note>
            </para>

            <para>
                The <filename>meta-poky</filename> layer inside Poky contains
                a <filename>conf</filename> directory that has example
                configuration files.
                These example files are used as a basis for creating actual
                configuration files when you source the build environment
                script
                (i.e.
                <ulink url='&YOCTO_DOCS_REF_URL;#structure-core-script'><filename>&OE_INIT_FILE;</filename></ulink>).
            </para>

            <para>
                Sourcing the build environment script creates a
                <ulink url='&YOCTO_DOCS_REF_URL;#build-directory'>Build Directory</ulink>
                if one does not already exist.
                BitBake uses the Build Directory for all its work during
                builds.
                The Build Directory has a <filename>conf</filename> directory
                that contains default versions of your
                <filename>local.conf</filename> and
                <filename>bblayers.conf</filename> configuration files.
                These default configuration files are created only if versions
                do not already exist in the Build Directory at the time you
                source the build environment setup script.
            </para>

            <para>
                Because the Poky repository is fundamentally an aggregation of
                existing repositories, some users might be familiar with
                running the <filename>&OE_INIT_FILE;</filename> script
                in the context of separate
                <ulink url='&YOCTO_DOCS_REF_URL;#oe-core'>OpenEmbedded-Core</ulink>
                and BitBake repositories rather than a single Poky repository.
                This discussion assumes the script is executed from
                within a cloned or unpacked version of Poky.
            </para>

            <para>
                Depending on where the script is sourced, different
                sub-scripts are called to set up the Build Directory
                (Yocto or OpenEmbedded).
                Specifically, the script
                <filename>scripts/oe-setup-builddir</filename> inside the
                poky directory sets up the Build Directory and seeds the
                directory (if necessary) with configuration files appropriate
                for the Yocto Project development environment.
                <note>
                    The <filename>scripts/oe-setup-builddir</filename> script
                    uses the <filename>$TEMPLATECONF</filename> variable to
                    determine which sample configuration files to locate.
                </note>
            </para>

            <para>
                The <filename>local.conf</filename> file provides many
                basic variables that define a build environment.
                Here is a list of a few.
                To see the default configurations in a
                <filename>local.conf</filename> file created by the build
                environment script, see the
                <filename>local.conf.sample</filename> in the
                <filename>meta-poky</filename> layer:
                <itemizedlist>
                    <listitem><para>
                        <emphasis>Parallelism Options:</emphasis>
                        Controlled by the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-BB_NUMBER_THREADS'><filename>BB_NUMBER_THREADS</filename></ulink>,
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-PARALLEL_MAKE'><filename>PARALLEL_MAKE</filename></ulink>,
                        and
                        <ulink url='&YOCTO_DOCS_BB_URL;#var-BB_NUMBER_PARSE_THREADS'><filename>BB_NUMBER_PARSE_THREADS</filename></ulink>
                        variables.
                        </para></listitem>
                    <listitem><para>
                        <emphasis>Target Machine Selection:</emphasis>
                        Controlled by the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-MACHINE'><filename>MACHINE</filename></ulink>
                        variable.
                        </para></listitem>
                    <listitem><para>
                        <emphasis>Download Directory:</emphasis>
                        Controlled by the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-DL_DIR'><filename>DL_DIR</filename></ulink>
                        variable.
                        </para></listitem>
                    <listitem><para>
                        <emphasis>Shared State Directory:</emphasis>
                        Controlled by the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SSTATE_DIR'><filename>SSTATE_DIR</filename></ulink>
                        variable.
                        </para></listitem>
                    <listitem><para>
                        <emphasis>Build Output:</emphasis>
                        Controlled by the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-TMPDIR'><filename>TMPDIR</filename></ulink>
                        variable.
                        </para></listitem>
                </itemizedlist>
                <note>
                    Configurations set in the
                    <filename>conf/local.conf</filename> file can also be set
                    in the <filename>conf/site.conf</filename> and
                    <filename>conf/auto.conf</filename> configuration files.
                </note>
            </para>

            <para>
                The <filename>bblayers.conf</filename> file tells BitBake what
                layers you want considered during the build.
                By default, the layers listed in this file include layers
                minimally needed by the build system.
                However, you must manually add any custom layers you have
                created.
                You can find more information on working with the
                <filename>bblayers.conf</filename> file in the
                "<ulink url='&YOCTO_DOCS_DEV_URL;#enabling-your-layer'>Enabling Your Layer</ulink>"
                section in the Yocto Project Development Tasks Manual.
            </para>

            <para>
                The files <filename>site.conf</filename> and
                <filename>auto.conf</filename> are not created by the
                environment initialization script.
                If you want the <filename>site.conf</filename> file, you
                need to create that yourself.
                The <filename>auto.conf</filename> file is typically created by
                an autobuilder:
                <itemizedlist>
                    <listitem><para>
                        <emphasis><filename>site.conf</filename>:</emphasis>
                        You can use the <filename>conf/site.conf</filename>
                        configuration file to configure multiple
                        build directories.
                        For example, suppose you had several build environments
                        and they shared some common features.
                        You can set these default build properties here.
                        A good example is perhaps the packaging format to use
                        through the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-PACKAGE_CLASSES'><filename>PACKAGE_CLASSES</filename></ulink>
                        variable.</para>

                        <para>One useful scenario for using the
                        <filename>conf/site.conf</filename> file is to extend
                        your
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-BBPATH'><filename>BBPATH</filename></ulink>
                        variable to include the path to a
                        <filename>conf/site.conf</filename>.
                        Then, when BitBake looks for Metadata using
                        <filename>BBPATH</filename>, it finds the
                        <filename>conf/site.conf</filename> file and applies
                        your common configurations found in the file.
                        To override configurations in a particular build
                        directory, alter the similar configurations within
                        that build directory's
                        <filename>conf/local.conf</filename> file.
                        </para></listitem>
                    <listitem><para>
                        <emphasis><filename>auto.conf</filename>:</emphasis>
                        The file is usually created and written to by
                        an autobuilder.
                        The settings put into the file are typically the
                        same as you would find in the
                        <filename>conf/local.conf</filename> or the
                        <filename>conf/site.conf</filename> files.
                        </para></listitem>
                </itemizedlist>
            </para>

            <para>
                You can edit all configuration files to further define
                any particular build environment.
                This process is represented by the "User Configuration Edits"
                box in the figure.
            </para>

            <para>
                When you launch your build with the
                <filename>bitbake <replaceable>target</replaceable></filename>
                command, BitBake sorts out the configurations to ultimately
                define your build environment.
                It is important to understand that the
                <ulink url='&YOCTO_DOCS_REF_URL;#build-system-term'>OpenEmbedded build system</ulink>
                reads the configuration files in a specific order:
                <filename>site.conf</filename>, <filename>auto.conf</filename>,
                and <filename>local.conf</filename>.
                And, the build system applies the normal assignment statement
                rules.
                Because the files are parsed in a specific order, variable
                assignments for the same variable could be affected.
                For example, if the <filename>auto.conf</filename> file and
                the <filename>local.conf</filename> set
                <replaceable>variable1</replaceable> to different values,
                because the build system parses <filename>local.conf</filename>
                after <filename>auto.conf</filename>,
                <replaceable>variable1</replaceable> is assigned the value from
                the <filename>local.conf</filename> file.
            </para>
        </section>

        <section id="metadata-machine-configuration-and-policy-configuration">
            <title>Metadata, Machine Configuration, and Policy Configuration</title>

            <para>
                The previous section described the user configurations that
                define BitBake's global behavior.
                This section takes a closer look at the layers the build system
                uses to further control the build.
                These layers provide Metadata for the software, machine, and
                policy.
            </para>

            <para>
                In general, three types of layer input exist:
                <itemizedlist>
                    <listitem><para>
                        <emphasis>Policy Configuration:</emphasis>
                        Distribution Layers provide top-level or general
                        policies for the image or SDK being built.
                        For example, this layer would dictate whether BitBake
                        produces RPM or IPK packages.
                        </para></listitem>
                    <listitem><para>
                        <emphasis>Machine Configuration:</emphasis>
                        Board Support Package (BSP) layers provide machine
                        configurations.
                        This type of information is specific to a particular
                        target architecture.
                        </para></listitem>
                    <listitem><para>
                        <emphasis>Metadata:</emphasis>
                        Software layers contain user-supplied recipe files,
                        patches, and append files.
                        </para></listitem>
                </itemizedlist>
            </para>

            <para>
                The following figure shows an expanded representation of the
                Metadata, Machine Configuration, and Policy Configuration input
                (layers) boxes of the
                <link linkend='general-yocto-environment-figure'>general Build Process figure</link>:
            </para>

            <para>
                <imagedata fileref="figures/layer-input.png" align="center" width="8in" depth="7.5in" />
            </para>

            <para>
                In general, all layers have a similar structure.
                They all contain a licensing file
                (e.g. <filename>COPYING</filename>) if the layer is to be
                distributed, a <filename>README</filename> file as good
                practice and especially if the layer is to be distributed, a
                configuration directory, and recipe directories.
            </para>

            <para>
                The Yocto Project has many layers that can be used.
                You can see a web-interface listing of them on the
                <ulink url="http://git.yoctoproject.org/">Source Repositories</ulink>
                page.
                The layers appear at the bottom categorized under
                "Yocto Metadata Layers."
                These layers are fundamentally a subset of the
                <ulink url="http://layers.openembedded.org/layerindex/layers/">OpenEmbedded Metadata Index</ulink>,
                which lists all layers provided by the OpenEmbedded community.
                <note>
                    Layers exist in the Yocto Project Source Repositories that
                    cannot be found in the OpenEmbedded Metadata Index.
                    These layers are either deprecated or experimental
                    in nature.
                </note>
            </para>

            <para>
                BitBake uses the <filename>conf/bblayers.conf</filename> file,
                which is part of the user configuration, to find what layers it
                should be using as part of the build.
            </para>

            <para>
                For more information on layers, see the
                "<ulink url='&YOCTO_DOCS_DEV_URL;#understanding-and-creating-layers'>Understanding and Creating Layers</ulink>"
                section in the Yocto Project Development Tasks Manual.
            </para>

            <section id="distro-layer">
                <title>Distro Layer</title>

                <para>
                    The distribution layer provides policy configurations for
                    your distribution.
                    Best practices dictate that you isolate these types of
                    configurations into their own layer.
                    Settings you provide in
                    <filename>conf/distro/<replaceable>distro</replaceable>.conf</filename> override
                    similar settings that BitBake finds in your
                    <filename>conf/local.conf</filename> file in the Build
                    Directory.
                </para>

                <para>
                    The following list provides some explanation and references
                    for what you typically find in the distribution layer:
                    <itemizedlist>
                        <listitem><para>
                            <emphasis>classes:</emphasis>
                            Class files (<filename>.bbclass</filename>) hold
                            common functionality that can be shared among
                            recipes in the distribution.
                            When your recipes inherit a class, they take on the
                            settings and functions for that class.
                            You can read more about class files in the
                            "<ulink url='&YOCTO_DOCS_REF_URL;#ref-classes'>Classes</ulink>"
                            chapter of the Yocto Reference Manual.
                            </para></listitem>
                        <listitem><para>
                            <emphasis>conf:</emphasis>
                            This area holds configuration files for the
                            layer (<filename>conf/layer.conf</filename>),
                            the distribution
                            (<filename>conf/distro/<replaceable>distro</replaceable>.conf</filename>),
                            and any distribution-wide include files.
                            </para></listitem>
                        <listitem><para>
                            <emphasis>recipes-*:</emphasis>
                            Recipes and append files that affect common
                            functionality across the distribution.
                            This area could include recipes and append files
                            to add distribution-specific configuration,
                            initialization scripts, custom image recipes,
                            and so forth.
                            </para></listitem>
                    </itemizedlist>
                </para>
            </section>

            <section id="bsp-layer">
                <title>BSP Layer</title>

                <para>
                    The BSP Layer provides machine configurations.
                    Everything in this layer is specific to the machine for
                    which you are building the image or the SDK.
                    A common structure or form is defined for BSP layers.
                    You can learn more about this structure in the
                    <ulink url='&YOCTO_DOCS_BSP_URL;'>Yocto Project Board Support Package (BSP) Developer's Guide</ulink>.
                    <note>
                        In order for a BSP layer to be considered compliant
                        with the Yocto Project, it must meet some structural
                        requirements.
                    </note>
                </para>

                <para>
                    The BSP Layer's configuration directory contains
                    configuration files for the machine
                    (<filename>conf/machine/<replaceable>machine</replaceable>.conf</filename>)
                    and, of course, the layer
                    (<filename>conf/layer.conf</filename>).
                </para>

                <para>
                    The remainder of the layer is dedicated to specific recipes
                    by function: <filename>recipes-bsp</filename>,
                    <filename>recipes-core</filename>,
                    <filename>recipes-graphics</filename>, and
                    <filename>recipes-kernel</filename>.
                    Metadata can exist for multiple formfactors, graphics
                    support systems, and so forth.
                    <note>
                        While the figure shows several
                        <filename>recipes-*</filename> directories, not all
                        these directories appear in all BSP layers.
                    </note>
                </para>
            </section>

            <section id="software-layer">
                <title>Software Layer</title>

                <para>
                    The software layer provides the Metadata for additional
                    software packages used during the build.
                    This layer does not include Metadata that is specific to
                    the distribution or the machine, which are found in their
                    respective layers.
                </para>

                <para>
                    This layer contains any new recipes that your project
                    needs in the form of recipe files.
                </para>
            </section>
        </section>

        <section id="sources-dev-environment">
            <title>Sources</title>

            <para>
                In order for the OpenEmbedded build system to create an
                image or any target, it must be able to access source files.
                The
                <link linkend='general-yocto-environment-figure'>general Build Process figure</link>
                represents source files using the "Upstream Project Releases",
                "Local Projects", and "SCMs (optional)" boxes.
                The figure represents mirrors, which also play a role in
                locating source files, with the "Source Mirror(s)" box.
            </para>

            <para>
                The method by which source files are ultimately organized is
                a function of the project.
                For example, for released software, projects tend to use
                tarballs or other archived files that can capture the
                state of a release guaranteeing that it is statically
                represented.
                On the other hand, for a project that is more dynamic or
                experimental in nature, a project might keep source files in a
                repository controlled by a Source Control Manager (SCM) such as
                Git.
                Pulling source from a repository allows you to control
                the point in the repository (the revision) from which you
                want to build software.
                Finally, a combination of the two might exist, which would
                give the consumer a choice when deciding where to get
                source files.
            </para>

            <para>
                BitBake uses the
                <ulink url='&YOCTO_DOCS_REF_URL;#var-SRC_URI'><filename>SRC_URI</filename></ulink>
                variable to point to source files regardless of their location.
                Each recipe must have a <filename>SRC_URI</filename> variable
                that points to the source.
            </para>

            <para>
                Another area that plays a significant role in where source
                files come from is pointed to by the
                <ulink url='&YOCTO_DOCS_REF_URL;#var-DL_DIR'><filename>DL_DIR</filename></ulink>
                variable.
                This area is a cache that can hold previously downloaded
                source.
                You can also instruct the OpenEmbedded build system to create
                tarballs from Git repositories, which is not the default
                behavior, and store them in the <filename>DL_DIR</filename>
                by using the
                <ulink url='&YOCTO_DOCS_REF_URL;#var-BB_GENERATE_MIRROR_TARBALLS'><filename>BB_GENERATE_MIRROR_TARBALLS</filename></ulink>
                variable.
            </para>

            <para>
                Judicious use of a <filename>DL_DIR</filename> directory can
                save the build system a trip across the Internet when looking
                for files.
                A good method for using a download directory is to have
                <filename>DL_DIR</filename> point to an area outside of your
                Build Directory.
                Doing so allows you to safely delete the Build Directory
                if needed without fear of removing any downloaded source file.
            </para>

            <para>
                The remainder of this section provides a deeper look into the
                source files and the mirrors.
                Here is a more detailed look at the source file area of the
                <link linkend='general-yocto-environment-figure'>general Build Process figure</link>:
                <imagedata fileref="figures/source-input.png" align="center" width="7in" depth="7.5in" />
            </para>

            <section id='upstream-project-releases'>
                <title>Upstream Project Releases</title>

                <para>
                    Upstream project releases exist anywhere in the form of an
                    archived file (e.g. tarball or zip file).
                    These files correspond to individual recipes.
                    For example, the figure uses specific releases each for
                    BusyBox, Qt, and Dbus.
                    An archive file can be for any released product that can be
                    built using a recipe.
                </para>
            </section>

            <section id='local-projects'>
                <title>Local Projects</title>

                <para>
                    Local projects are custom bits of software the user
                    provides.
                    These bits reside somewhere local to a project - perhaps
                    a directory into which the user checks in items (e.g.
                    a local directory containing a development source tree
                    used by the group).
                </para>

                <para>
                    The canonical method through which to include a local
                    project is to use the
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-classes-externalsrc'><filename>externalsrc</filename></ulink>
                    class to include that local project.
                    You use either the <filename>local.conf</filename> or a
                    recipe's append file to override or set the
                    recipe to point to the local directory on your disk to pull
                    in the whole source tree.
                </para>

                <para>
                    For information on how to use the
                    <filename>externalsrc</filename> class, see the
                    "<ulink url='&YOCTO_DOCS_REF_URL;#ref-classes-externalsrc'><filename>externalsrc.bbclass</filename></ulink>"
                    section.
                </para>
            </section>

            <section id='scms'>
                <title>Source Control Managers (Optional)</title>

                <para>
                    Another place the build system can get source files from is
                    through an SCM such as Git or Subversion.
                    In this case, a repository is cloned or checked out.
                    The
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-fetch'><filename>do_fetch</filename></ulink>
                    task inside BitBake uses
                    the <ulink url='&YOCTO_DOCS_REF_URL;#var-SRC_URI'><filename>SRC_URI</filename></ulink>
                    variable and the argument's prefix to determine the correct
                    fetcher module.
                    <note>
                        For information on how to have the OpenEmbedded build
                        system generate tarballs for Git repositories and place
                        them in the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-DL_DIR'><filename>DL_DIR</filename></ulink>
                        directory, see the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-BB_GENERATE_MIRROR_TARBALLS'><filename>BB_GENERATE_MIRROR_TARBALLS</filename></ulink>
                        variable.
                    </note>
                </para>

                <para>
                    When fetching a repository, BitBake uses the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-SRCREV'><filename>SRCREV</filename></ulink>
                    variable to determine the specific revision from which to
                    build.
                </para>
            </section>

            <section id='source-mirrors'>
                <title>Source Mirror(s)</title>

                <para>
                    Two kinds of mirrors exist: pre-mirrors and regular
                    mirrors.
                    The
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-PREMIRRORS'><filename>PREMIRRORS</filename></ulink>
                    and
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-MIRRORS'><filename>MIRRORS</filename></ulink>
                    variables point to these, respectively.
                    BitBake checks pre-mirrors before looking upstream for any
                    source files.
                    Pre-mirrors are appropriate when you have a shared
                    directory that is not a directory defined by the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-DL_DIR'><filename>DL_DIR</filename></ulink>
                    variable.
                    A Pre-mirror typically points to a shared directory that is
                    local to your organization.
                </para>

                <para>
                    Regular mirrors can be any site across the Internet
                    that is used as an alternative location for source
                    code should the primary site not be functioning for
                    some reason or another.
                </para>
            </section>
        </section>

        <section id="package-feeds-dev-environment">
            <title>Package Feeds</title>

            <para>
                When the OpenEmbedded build system generates an image or an
                SDK, it gets the packages from a package feed area located
                in the
                <ulink url='&YOCTO_DOCS_REF_URL;#build-directory'>Build Directory</ulink>.
                The
                <link linkend='general-yocto-environment-figure'>general Build Process figure</link>
                shows this package feeds area in the upper-right corner.
            </para>

            <para>
                This section looks a little closer into the package feeds
                area used by the build system.
                Here is a more detailed look at the area:
                <imagedata fileref="figures/package-feeds.png" align="center" width="7in" depth="6in" />
            </para>

            <para>
                Package feeds are an intermediary step in the build process.
                The OpenEmbedded build system provides classes to generate
                different package types, and you specify which classes to
                enable through the
                <ulink url='&YOCTO_DOCS_REF_URL;#var-PACKAGE_CLASSES'><filename>PACKAGE_CLASSES</filename></ulink>
                variable.
                Before placing the packages into package feeds,
                the build process validates them with generated output quality
                assurance checks through the
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-classes-insane'><filename>insane</filename></ulink>
                class.
            </para>

            <para>
                The package feed area resides in the Build Directory.
                The directory the build system uses to temporarily store
                packages is determined by a combination of variables and the
                particular package manager in use.
                See the "Package Feeds" box in the illustration and note the
                information to the right of that area.
                In particular, the following defines where package files are
                kept:
                <itemizedlist>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-DEPLOY_DIR'><filename>DEPLOY_DIR</filename></ulink>:
                        Defined as <filename>tmp/deploy</filename> in the Build
                        Directory.
                        </para></listitem>
                    <listitem><para>
                        <filename>DEPLOY_DIR_*</filename>:
                        Depending on the package manager used, the package type
                        sub-folder.
                        Given RPM, IPK, or DEB packaging and tarball creation,
                        the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-DEPLOY_DIR_RPM'><filename>DEPLOY_DIR_RPM</filename></ulink>,
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-DEPLOY_DIR_IPK'><filename>DEPLOY_DIR_IPK</filename></ulink>,
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-DEPLOY_DIR_DEB'><filename>DEPLOY_DIR_DEB</filename></ulink>,
                        or
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-DEPLOY_DIR_TAR'><filename>DEPLOY_DIR_TAR</filename></ulink>,
                        variables are used, respectively.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-PACKAGE_ARCH'><filename>PACKAGE_ARCH</filename></ulink>:
                        Defines architecture-specific sub-folders.
                        For example, packages could exist for the i586 or
                        qemux86 architectures.
                        </para></listitem>
                </itemizedlist>
            </para>

            <para>
                BitBake uses the
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package_write_deb'><filename>do_package_write_*</filename></ulink>
                tasks to generate packages and place them into the package
                holding area (e.g. <filename>do_package_write_ipk</filename>
                for IPK packages).
                See the
                "<ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package_write_deb'><filename>do_package_write_deb</filename></ulink>",
                "<ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package_write_ipk'><filename>do_package_write_ipk</filename></ulink>",
                "<ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package_write_rpm'><filename>do_package_write_rpm</filename></ulink>",
                and
                "<ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package_write_tar'><filename>do_package_write_tar</filename></ulink>"
                sections in the Yocto Project Reference Manual
                for additional information.
                As an example, consider a scenario where an IPK packaging
                manager is being used and package architecture support for
                both i586 and qemux86 exist.
                Packages for the i586 architecture are placed in
                <filename>build/tmp/deploy/ipk/i586</filename>, while packages
                for the qemux86 architecture are placed in
                <filename>build/tmp/deploy/ipk/qemux86</filename>.
            </para>
        </section>

        <section id='bitbake-dev-environment'>
            <title>BitBake</title>

            <para>
                The OpenEmbedded build system uses
                <ulink url='&YOCTO_DOCS_REF_URL;#bitbake-term'>BitBake</ulink>
                to produce images.
                You can see from the
                <link linkend='general-yocto-environment-figure'>general Build Process figure</link>,
                the BitBake area consists of several functional areas.
                This section takes a closer look at each of those areas.
            </para>

            <para>
                Separate documentation exists for the BitBake tool.
                See the
                <ulink url='&YOCTO_DOCS_BB_URL;#bitbake-user-manual'>BitBake User Manual</ulink>
                for reference material on BitBake.
            </para>

            <section id='source-fetching-dev-environment'>
                <title>Source Fetching</title>

                <para>
                    The first stages of building a recipe are to fetch and
                    unpack the source code:
                    <imagedata fileref="figures/source-fetching.png" align="center" width="6.5in" depth="5in" />
                </para>

                <para>
                    The
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-fetch'><filename>do_fetch</filename></ulink>
                    and
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-unpack'><filename>do_unpack</filename></ulink>
                    tasks fetch the source files and unpack them into the work
                    directory.
                    <note>
                        For every local file (e.g. <filename>file://</filename>)
                        that is part of a recipe's
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SRC_URI'><filename>SRC_URI</filename></ulink>
                        statement, the OpenEmbedded build system takes a
                        checksum of the file for the recipe and inserts the
                        checksum into the signature for the
                        <filename>do_fetch</filename>.
                        If any local file has been modified, the
                        <filename>do_fetch</filename> task and all tasks that
                        depend on it are re-executed.
                    </note>
                    By default, everything is accomplished in the
                    <ulink url='&YOCTO_DOCS_REF_URL;#build-directory'>Build Directory</ulink>,
                    which has a defined structure.
                    For additional general information on the Build Directory,
                    see the
                    "<ulink url='&YOCTO_DOCS_REF_URL;#structure-core-build'><filename>build/</filename></ulink>"
                    section in the Yocto Project Reference Manual.
                </para>

                <para>
                    Unpacked source files are pointed to by the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-S'><filename>S</filename></ulink>
                    variable.
                    Each recipe has an area in the Build Directory where the
                    unpacked source code resides.
                    The name of that directory for any given recipe is defined
                    from several different variables.
                    You can see the variables that define these directories
                    by looking at the figure:
                    <itemizedlist>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-TMPDIR'><filename>TMPDIR</filename></ulink>:
                            The base directory where the OpenEmbedded build
                            system performs all its work during the build.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PACKAGE_ARCH'><filename>PACKAGE_ARCH</filename></ulink>:
                            The architecture of the built package or packages.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-TARGET_OS'><filename>TARGET_OS</filename></ulink>:
                            The operating system of the target device.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PN'><filename>PN</filename></ulink>:
                            The name of the built package.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PV'><filename>PV</filename></ulink>:
                            The version of the recipe used to build the
                            package.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PR'><filename>PR</filename></ulink>:
                            The revision of the recipe used to build the
                            package.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-WORKDIR'><filename>WORKDIR</filename></ulink>:
                            The location within <filename>TMPDIR</filename>
                            where a specific package is built.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-S'><filename>S</filename></ulink>:
                            Contains the unpacked source files for a given
                            recipe.
                            </para></listitem>
                    </itemizedlist>
                </para>
            </section>

            <section id='patching-dev-environment'>
                <title>Patching</title>

                <para>
                    Once source code is fetched and unpacked, BitBake locates
                    patch files and applies them to the source files:
                    <imagedata fileref="figures/patching.png" align="center" width="6in" depth="5in" />
                </para>

                <para>
                    The
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-patch'><filename>do_patch</filename></ulink>
                    task processes recipes by using the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-SRC_URI'><filename>SRC_URI</filename></ulink>
                    variable to locate applicable patch files, which by default
                    are <filename>*.patch</filename> or
                    <filename>*.diff</filename> files, or any file if
                    "apply=yes" is specified for the file in
                    <filename>SRC_URI</filename>.
                </para>

                <para>
                    BitBake finds and applies multiple patches for a single
                    recipe in the order in which it finds the patches.
                    Patches are applied to the recipe's source files located
                    in the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-S'><filename>S</filename></ulink>
                    directory.
                </para>

                <para>
                    For more information on how the source directories are
                    created, see the
                    "<link linkend='source-fetching-dev-environment'>Source Fetching</link>"
                    section.
                </para>
            </section>

            <section id='configuration-and-compilation-dev-environment'>
                <title>Configuration and Compilation</title>

                <para>
                    After source code is patched, BitBake executes tasks that
                    configure and compile the source code:
                    <imagedata fileref="figures/configuration-compile-autoreconf.png" align="center" width="7in" depth="5in" />
                </para>

                <para>
                    This step in the build process consists of three tasks:
                    <itemizedlist>
                        <listitem><para>
                            <emphasis><ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-prepare_recipe_sysroot'><filename>do_prepare_recipe_sysroot</filename></ulink></emphasis>:
                            This task sets up the two sysroots in
                            <filename>${</filename><ulink url='&YOCTO_DOCS_REF_URL;#var-WORKDIR'><filename>WORKDIR</filename></ulink><filename>}</filename>
                            (i.e. <filename>recipe-sysroot</filename> and
                            <filename>recipe-sysroot-native</filename>) so that
                            the sysroots contain the contents of the
                            <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-populate_sysroot'><filename>do_populate_sysroot</filename></ulink>
                            tasks of the recipes on which the recipe
                            containing the tasks depends.
                            A sysroot exists for both the target and for the
                            native binaries, which run on the host system.
                            </para></listitem>
                        <listitem><para>
                            <emphasis><filename>do_configure</filename></emphasis>:
                            This task configures the source by enabling and
                            disabling any build-time and configuration options
                            for the software being built.
                            Configurations can come from the recipe itself as
                            well as from an inherited class.
                            Additionally, the software itself might configure
                            itself depending on the target for which it is
                            being built.</para>

                            <para>The configurations handled by the
                            <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-configure'><filename>do_configure</filename></ulink>
                            task are specific to source code configuration for
                            the source code being built by the recipe.</para>

                            <para>If you are using the
                            <ulink url='&YOCTO_DOCS_REF_URL;#ref-classes-autotools'><filename>autotools</filename></ulink>
                            class, you can add additional configuration options
                            by using the
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-EXTRA_OECONF'><filename>EXTRA_OECONF</filename></ulink>
                            or
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PACKAGECONFIG_CONFARGS'><filename>PACKAGECONFIG_CONFARGS</filename></ulink>
                            variables.
                            For information on how this variable works within
                            that class, see the
                            <filename>meta/classes/autotools.bbclass</filename>
                            file.
                            </para></listitem>
                        <listitem><para>
                            <emphasis><filename>do_compile</filename></emphasis>:
                            Once a configuration task has been satisfied, BitBake
                            compiles the source using the
                            <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-compile'><filename>do_compile</filename></ulink>
                            task.
                            Compilation occurs in the directory pointed to by
                            the
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-B'><filename>B</filename></ulink>
                            variable.
                            Realize that the <filename>B</filename> directory
                            is, by default, the same as the
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-S'><filename>S</filename></ulink>
                            directory.
                            </para></listitem>
                        <listitem><para>
                            <emphasis><filename>do_install</filename></emphasis>:
                            Once compilation is done, BitBake executes the
                            <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-install'><filename>do_install</filename></ulink>
                            task.
                            This task copies files from the
                            <filename>B</filename> directory and places them
                            in a holding area pointed to by the
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-D'><filename>D</filename></ulink>
                            variable.
                            </para></listitem>
                    </itemizedlist>
                </para>
            </section>

            <section id='package-splitting-dev-environment'>
                <title>Package Splitting</title>

                <para>
                    After source code is configured and compiled, the
                    OpenEmbedded build system analyzes
                    the results and splits the output into packages:
                    <imagedata fileref="figures/analysis-for-package-splitting.png" align="center" width="7in" depth="7in" />
                </para>

                <para>
                    The
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package'><filename>do_package</filename></ulink>
                    and
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-packagedata'><filename>do_packagedata</filename></ulink>
                    tasks combine to analyze the files found in the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-D'><filename>D</filename></ulink>
                    directory and split them into subsets based on available
                    packages and files.
                    The analyzing process involves the following as well as
                    other items: splitting out debugging symbols, looking at
                    shared library dependencies between packages, and looking
                    at package relationships.
                    The <filename>do_packagedata</filename> task creates
                    package metadata based on the analysis such that the
                    OpenEmbedded build system can generate the final packages.
                    Working, staged, and intermediate results of the analysis
                    and package splitting process use these areas:
                    <itemizedlist>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PKGD'><filename>PKGD</filename></ulink>:
                            The destination directory for packages before they
                            are split.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PKGDATA_DIR'><filename>PKGDATA_DIR</filename></ulink>:
                            A shared, global-state directory that holds data
                            generated during the packaging process.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PKGDESTWORK'><filename>PKGDESTWORK</filename></ulink>:
                            A temporary work area used by the
                            <filename>do_package</filename> task.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PKGDEST'><filename>PKGDEST</filename></ulink>:
                            The parent directory for packages after they have
                            been split.
                            </para></listitem>
                    </itemizedlist>
                    The
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-FILES'><filename>FILES</filename></ulink>
                    variable defines the files that go into each package in
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-PACKAGES'><filename>PACKAGES</filename></ulink>.
                    If you want details on how this is accomplished, you can
                    look at the
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-classes-package'><filename>package</filename></ulink>
                    class.
                </para>

                <para>
                    Depending on the type of packages being created (RPM, DEB,
                    or IPK), the
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package_write_deb'><filename>do_package_write_*</filename></ulink>
                    task creates the actual packages and places them in the
                    Package Feed area, which is
                    <filename>${TMPDIR}/deploy</filename>.
                    You can see the
                    "<link linkend='package-feeds-dev-environment'>Package Feeds</link>"
                    section for more detail on that part of the build process.
                    <note>
                        Support for creating feeds directly from the
                        <filename>deploy/*</filename> directories does not
                        exist.
                        Creating such feeds usually requires some kind of feed
                        maintenance mechanism that would upload the new
                        packages into an official package feed (e.g. the
                        Ångström distribution).
                        This functionality is highly distribution-specific
                        and thus is not provided out of the box.
                    </note>
                </para>
            </section>

            <section id='image-generation-dev-environment'>
                <title>Image Generation</title>

                <para>
                    Once packages are split and stored in the Package Feeds
                    area, the OpenEmbedded build system uses BitBake to
                    generate the root filesystem image:
                    <imagedata fileref="figures/image-generation.png" align="center" width="6in" depth="7in" />
                </para>

                <para>
                    The image generation process consists of several stages and
                    depends on several tasks and variables.
                    The
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-rootfs'><filename>do_rootfs</filename></ulink>
                    task creates the root filesystem (file and directory
                    structure) for an image.
                    This task uses several key variables to help create the
                    list of packages to actually install:
                    <itemizedlist>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-IMAGE_INSTALL'><filename>IMAGE_INSTALL</filename></ulink>:
                            Lists out the base set of packages to install from
                            the Package Feeds area.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PACKAGE_EXCLUDE'><filename>PACKAGE_EXCLUDE</filename></ulink>:
                            Specifies packages that should not be installed.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-IMAGE_FEATURES'><filename>IMAGE_FEATURES</filename></ulink>:
                            Specifies features to include in the image.
                            Most of these features map to additional packages
                            for installation.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PACKAGE_CLASSES'><filename>PACKAGE_CLASSES</filename></ulink>:
                            Specifies the package backend to use and
                            consequently helps determine where to locate
                            packages within the Package Feeds area.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-IMAGE_LINGUAS'><filename>IMAGE_LINGUAS</filename></ulink>:
                            Determines the language(s) for which additional
                            language support packages are installed.
                            </para></listitem>
                        <listitem><para>
                            <ulink url='&YOCTO_DOCS_REF_URL;#var-PACKAGE_INSTALL'><filename>PACKAGE_INSTALL</filename></ulink>:
                            The final list of packages passed to the package manager
                            for installation into the image.
                            </para></listitem>
                    </itemizedlist>
                </para>

                <para>
                    With
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-IMAGE_ROOTFS'><filename>IMAGE_ROOTFS</filename></ulink>
                    pointing to the location of the filesystem under
                    construction and the <filename>PACKAGE_INSTALL</filename>
                    variable providing the final list of packages to install,
                    the root file system is created.
                </para>

                <para>
                    Package installation is under control of the package
                    manager (e.g. dnf/rpm, opkg, or apt/dpkg) regardless of
                    whether or not package management is enabled for the
                    target.
                    At the end of the process, if package management is not
                    enabled for the target, the package manager's data files
                    are deleted from the root filesystem.
                    As part of the final stage of package installation,
                    postinstall scripts that are part of the packages are run.
                    Any scripts that fail to run
                    on the build host are run on the target when the target
                    system is first booted.
                    If you are using a
                    <ulink url='&YOCTO_DOCS_DEV_URL;#creating-a-read-only-root-filesystem'>read-only root filesystem</ulink>,
                    all the post installation scripts must succeed during the
                    package installation phase since the root filesystem is
                    read-only.
                </para>

                <para>
                    The final stages of the <filename>do_rootfs</filename> task
                    handle post processing.
                    Post processing includes creation of a manifest file and
                    optimizations.
                </para>

                <para>
                    The manifest file (<filename>.manifest</filename>) resides
                    in the same directory as the root filesystem image.
                    This file lists out, line-by-line, the installed packages.
                    The manifest file is useful for the
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-classes-testimage*'><filename>testimage</filename></ulink>
                    class, for example, to determine whether or not to run
                    specific tests.
                    See the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-IMAGE_MANIFEST'><filename>IMAGE_MANIFEST</filename></ulink>
                    variable for additional information.
                </para>

                <para>
                    Optimizing processes run across the image include
                    <filename>mklibs</filename>, <filename>prelink</filename>,
                    and any other post-processing commands as defined by the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-ROOTFS_POSTPROCESS_COMMAND'><filename>ROOTFS_POSTPROCESS_COMMAND</filename></ulink>
                    variable.
                    The <filename>mklibs</filename> process optimizes the size
                    of the libraries, while the <filename>prelink</filename>
                    process optimizes the dynamic linking of shared libraries
                    to reduce start up time of executables.
                </para>

                <para>
                    After the root filesystem is built, processing begins on
                    the image through the
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-image'><filename>do_image</filename></ulink>
                    task.
                    The build system runs any pre-processing commands as
                    defined by the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-IMAGE_PREPROCESS_COMMAND'><filename>IMAGE_PREPROCESS_COMMAND</filename></ulink>
                    variable.
                    This variable specifies a list of functions to call before
                    the OpenEmbedded build system creates the final image
                    output files.
                </para>

                <para>
                    The OpenEmbedded build system dynamically creates
                    <filename>do_image_*</filename> tasks as needed, based
                    on the image types specified in the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-IMAGE_FSTYPES'><filename>IMAGE_FSTYPES</filename></ulink>
                    variable.
                    The process turns everything into an image file or a set of
                    image files and compresses the root filesystem image to
                    reduce the overall size of the image.
                    The formats used for the root filesystem depend on the
                    <filename>IMAGE_FSTYPES</filename> variable.
                </para>

                <para>
                    As an example, a dynamically created task when creating a
                    particular image <replaceable>type</replaceable> would
                    take the following form:
                    <literallayout class='monospaced'>
     do_image_<replaceable>type</replaceable>[depends]
                    </literallayout>
                    So, if the <replaceable>type</replaceable> as specified by
                    the <filename>IMAGE_FSTYPES</filename> were
                    <filename>ext4</filename>, the dynamically generated task
                    would be as follows:
                    <literallayout class='monospaced'>
     do_image_ext4[depends]
                    </literallayout>
                </para>

                <para>
                    The final task involved in image creation is the
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-image-complete'><filename>do_image_complete</filename></ulink>
                    task.
                    This task completes the image by applying any image
                    post processing as defined through the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-IMAGE_POSTPROCESS_COMMAND'><filename>IMAGE_POSTPROCESS_COMMAND</filename></ulink>
                    variable.
                    The variable specifies a list of functions to call once the
                    OpenEmbedded build system has created the final image
                    output files.
                    <note>
                        The entire image generation process is run under
                        Pseudo.
                        Running under Pseudo ensures that the files in the
                        root filesystem have correct ownership.
                    </note>
                </para>
            </section>

            <section id='sdk-generation-dev-environment'>
                <title>SDK Generation</title>

                <para>
                    The OpenEmbedded build system uses BitBake to generate the
                    Software Development Kit (SDK) installer script for both
                    the standard and extensible SDKs:
                    <imagedata fileref="figures/sdk-generation.png" align="center" />
                    <note>
                        For more information on the cross-development toolchain
                        generation, see the
                        "<link linkend='cross-development-toolchain-generation'>Cross-Development Toolchain Generation</link>"
                        section.
                        For information on advantages gained when building a
                        cross-development toolchain using the
                        <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-populate_sdk'><filename>do_populate_sdk</filename></ulink>
                        task, see the
                        "<ulink url='&YOCTO_DOCS_SDK_URL;#sdk-building-an-sdk-installer'>Building an SDK Installer</ulink>"
                        section in the Yocto Project Application Development
                        and the Extensible Software Development Kit (SDK)
                        manual.
                    </note>
                </para>

                <para>
                    Like image generation, the SDK script process consists of
                    several stages and depends on many variables.
                    The <filename>do_populate_sdk</filename> and
                    <filename>do_populate_sdk_ext</filename> tasks use these
                    key variables to help create the list of packages to
                    actually install.
                    For information on the variables listed in the figure,
                    see the
                    "<link linkend='sdk-dev-environment'>Application Development SDK</link>"
                    section.
                </para>

                <para>
                    The <filename>do_populate_sdk</filename> task helps create
                    the standard SDK and handles two parts: a target part and a
                    host part.
                    The target part is the part built for the target hardware
                    and includes libraries and headers.
                    The host part is the part of the SDK that runs on the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-SDKMACHINE'><filename>SDKMACHINE</filename></ulink>.
                </para>

                <para>
                    The <filename>do_populate_sdk_ext</filename> task helps
                    create the extensible SDK and handles host and target parts
                    differently than its counter part does for the standard SDK.
                    For the extensible SDK, the task encapsulates the build
                    system, which includes everything needed (host and target)
                    for the SDK.
                </para>

                <para>
                    Regardless of the type of SDK being constructed, the
                    tasks perform some cleanup after which a cross-development
                    environment setup script and any needed configuration files
                    are created.
                    The final output is the Cross-development
                    toolchain installation script (<filename>.sh</filename>
                    file), which includes the environment setup script.
                </para>
            </section>

            <section id='stamp-files-and-the-rerunning-of-tasks'>
                <title>Stamp Files and the Rerunning of Tasks</title>

                <para>
                    For each task that completes successfully, BitBake writes a
                    stamp file into the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-STAMPS_DIR'><filename>STAMPS_DIR</filename></ulink>
                    directory.
                    The beginning of the stamp file's filename is determined
                    by the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-STAMP'><filename>STAMP</filename></ulink>
                    variable, and the end of the name consists of the task's
                    name and current
                    <ulink url='&YOCTO_DOCS_CM_URL;#overview-checksums'>input checksum</ulink>.
                    <note>
                        This naming scheme assumes that
                        <ulink url='&YOCTO_DOCS_BB_URL;#var-BB_SIGNATURE_HANDLER'><filename>BB_SIGNATURE_HANDLER</filename></ulink>
                        is "OEBasicHash", which is almost always the case in
                        current OpenEmbedded.
                    </note>
                    To determine if a task needs to be rerun, BitBake checks
                    if a stamp file with a matching input checksum exists
                    for the task.
                    If such a stamp file exists, the task's output is
                    assumed to exist and still be valid.
                    If the file does not exist, the task is rerun.
                    <note>
                        <para>The stamp mechanism is more general than the
                        shared state (sstate) cache mechanism described in the
                        "<link linkend='setscene-tasks-and-shared-state'>Setscene Tasks and Shared State</link>"
                        section.
                        BitBake avoids rerunning any task that has a valid
                        stamp file, not just tasks that can be accelerated
                        through the sstate cache.</para>

                        <para>However, you should realize that stamp files only
                        serve as a marker that some work has been done and that
                        these files do not record task output.
                        The actual task output would usually be somewhere in
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-TMPDIR'><filename>TMPDIR</filename></ulink>
                        (e.g. in some recipe's
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-WORKDIR'><filename>WORKDIR</filename></ulink>.)
                        What the sstate cache mechanism adds is a way to cache
                        task output that can then be shared between build
                        machines.</para>
                    </note>
                    Since <filename>STAMPS_DIR</filename> is usually a
                    subdirectory of <filename>TMPDIR</filename>, removing
                    <filename>TMPDIR</filename> will also remove
                    <filename>STAMPS_DIR</filename>, which means tasks will
                    properly be rerun to repopulate
                    <filename>TMPDIR</filename>.
                </para>

                <para>
                    If you want some task to always be considered "out of
                    date", you can mark it with the
                    <ulink url='&YOCTO_DOCS_BB_URL;#variable-flags'><filename>nostamp</filename></ulink>
                    varflag.
                    If some other task depends on such a task, then that
                    task will also always be considered out of date, which
                    might not be what you want.
                </para>

                <para>
                    For details on how to view information about a task's
                    signature, see the
                    "<ulink url='&YOCTO_DOCS_DEV_URL;#dev-viewing-task-variable-dependencies'>Viewing Task Variable Dependencies</ulink>"
                    section in the Yocto Project Development Tasks Manual.
                </para>
            </section>

            <section id='setscene-tasks-and-shared-state'>
                <title>Setscene Tasks and Shared State</title>

                <para>
                    The description of tasks so far assumes that BitBake needs
                    to build everything and there are no prebuilt objects
                    available.
                    BitBake does support skipping tasks if prebuilt objects are
                    available.
                    These objects are usually made available in the form of a
                    shared state (sstate) cache.
                    <note>
                        For information on variables affecting sstate, see the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SSTATE_DIR'><filename>SSTATE_DIR</filename></ulink>
                        and
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SSTATE_MIRRORS'><filename>SSTATE_MIRRORS</filename></ulink>
                        variables.
                    </note>
                </para>

                <para>
                    The idea of a setscene task (i.e
                    <filename>do_</filename><replaceable>taskname</replaceable><filename>_setscene</filename>)
                    is a version of the task where
                    instead of building something, BitBake can skip to the end
                    result and simply place a set of files into specific
                    locations as needed.
                    In some cases, it makes sense to have a setscene task
                    variant (e.g. generating package files in the
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package_write_deb'><filename>do_package_write_*</filename></ulink>
                    task).
                    In other cases, it does not make sense, (e.g. a
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-patch'><filename>do_patch</filename></ulink>
                    task or
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-unpack'><filename>do_unpack</filename></ulink>
                    task) since the work involved would be equal to or greater
                    than the underlying task.
                </para>

                <para>
                    In the OpenEmbedded build system, the common tasks that
                    have setscene variants are
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package'><filename>do_package</filename></ulink>,
                    <filename>do_package_write_*</filename>,
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-deploy'><filename>do_deploy</filename></ulink>,
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-packagedata'><filename>do_packagedata</filename></ulink>,
                    and
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-populate_sysroot'><filename>do_populate_sysroot</filename></ulink>.
                    Notice that these are most of the tasks whose output is an
                    end result.
                </para>

                <para>
                    The OpenEmbedded build system has knowledge of the
                    relationship between these tasks and other tasks that
                    precede them.
                    For example, if BitBake runs
                    <filename>do_populate_sysroot_setscene</filename> for
                    something, there is little point in running any of the
                    <filename>do_fetch</filename>,
                    <filename>do_unpack</filename>,
                    <filename>do_patch</filename>,
                    <filename>do_configure</filename>,
                    <filename>do_compile</filename>, and
                    <filename>do_install</filename> tasks.
                    However, if <filename>do_package</filename> needs to be
                    run, BitBake would need to run those other tasks.
                </para>

                <para>
                    It becomes more complicated if everything can come
                    from an sstate cache because some objects are simply
                    not required at all.
                    For example, you do not need a compiler or native tools,
                    such as quilt, if there is nothing to compile or patch.
                    If the <filename>do_package_write_*</filename> packages
                    are available from sstate, BitBake does not need the
                    <filename>do_package</filename> task data.
                </para>

                <para>
                    To handle all these complexities, BitBake runs in two
                    phases.
                    The first is the "setscene" stage.
                    During this stage, BitBake first checks the sstate cache
                    for any targets it is planning to build.
                    BitBake does a fast check to see if the object exists
                    rather than a complete download.
                    If nothing exists, the second phase, which is the setscene
                    stage, completes and the main build proceeds.
                </para>

                <para>
                    If objects are found in the sstate cache, the OpenEmbedded
                    build system works backwards from the end targets specified
                    by the user.
                    For example, if an image is being built, the OpenEmbedded
                    build system first looks for the packages needed for
                    that image and the tools needed to construct an image.
                    If those are available, the compiler is not needed.
                    Thus, the compiler is not even downloaded.
                    If something was found to be unavailable, or the
                    download or setscene task fails, the OpenEmbedded build
                    system then tries to install dependencies, such as the
                    compiler, from the cache.
                </para>

                <para>
                    The availability of objects in the sstate cache is
                    handled by the function specified by the
                    <ulink url='&YOCTO_DOCS_BB_URL;#var-BB_HASHCHECK_FUNCTION'><filename>BB_HASHCHECK_FUNCTION</filename></ulink>
                    variable and returns a list of the objects that are
                    available.
                    The function specified by the
                    <ulink url='&YOCTO_DOCS_BB_URL;#var-BB_SETSCENE_DEPVALID'><filename>BB_SETSCENE_DEPVALID</filename></ulink>
                    variable is the function that determines whether a given
                    dependency needs to be followed, and whether for any given
                    relationship the function needs to be passed.
                    The function returns a True or False value.
                </para>
            </section>
        </section>

        <section id='images-dev-environment'>
            <title>Images</title>

            <para>
                The images produced by the OpenEmbedded build system
                are compressed forms of the
                root filesystem that are ready to boot on a target device.
                You can see from the
                <link linkend='general-yocto-environment-figure'>general Build Process figure</link>
                that BitBake output, in part, consists of images.
                This section is going to look more closely at this output:
                <imagedata fileref="figures/images.png" align="center" width="5.5in" depth="5.5in" />
            </para>

            <para>
                For a list of example images that the Yocto Project provides,
                see the
                "<ulink url='&YOCTO_DOCS_REF_URL;#ref-images'>Images</ulink>"
                chapter in the Yocto Project Reference Manual.
            </para>

            <para>
                Images are written out to the
                <ulink url='&YOCTO_DOCS_REF_URL;#build-directory'>Build Directory</ulink>
                inside the
                <filename>tmp/deploy/images/<replaceable>machine</replaceable>/</filename>
                folder as shown in the figure.
                This folder contains any files expected to be loaded on the
                target device.
                The
                <ulink url='&YOCTO_DOCS_REF_URL;#var-DEPLOY_DIR'><filename>DEPLOY_DIR</filename></ulink>
                variable points to the <filename>deploy</filename> directory,
                while the
                <ulink url='&YOCTO_DOCS_REF_URL;#var-DEPLOY_DIR_IMAGE'><filename>DEPLOY_DIR_IMAGE</filename></ulink>
                variable points to the appropriate directory containing images
                for the current configuration.
                <itemizedlist>
                    <listitem><para>
                        <filename><replaceable>kernel-image</replaceable></filename>:
                        A kernel binary file.
                        The
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-KERNEL_IMAGETYPE'><filename>KERNEL_IMAGETYPE</filename></ulink>
                        variable setting determines the naming scheme for the
                        kernel image file.
                        Depending on that variable, the file could begin with
                        a variety of naming strings.
                        The
                        <filename>deploy/images/<replaceable>machine</replaceable></filename>
                        directory can contain multiple image files for the
                        machine.
                        </para></listitem>
                    <listitem><para>
                        <filename><replaceable>root-filesystem-image</replaceable></filename>:
                        Root filesystems for the target device (e.g.
                        <filename>*.ext3</filename> or
                        <filename>*.bz2</filename> files).
                        The
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-IMAGE_FSTYPES'><filename>IMAGE_FSTYPES</filename></ulink>
                        variable setting determines the root filesystem image
                        type.
                        The
                        <filename>deploy/images/<replaceable>machine</replaceable></filename>
                        directory can contain multiple root filesystems for the
                        machine.
                        </para></listitem>
                    <listitem><para>
                        <filename><replaceable>kernel-modules</replaceable></filename>:
                        Tarballs that contain all the modules built for the
                        kernel.
                        Kernel module tarballs exist for legacy purposes and
                        can be suppressed by setting the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-MODULE_TARBALL_DEPLOY'><filename>MODULE_TARBALL_DEPLOY</filename></ulink>
                        variable to "0".
                        The
                        <filename>deploy/images/<replaceable>machine</replaceable></filename>
                        directory can contain multiple kernel module tarballs
                        for the machine.
                        </para></listitem>
                    <listitem><para>
                        <filename><replaceable>bootloaders</replaceable></filename>:
                        Bootloaders supporting the image, if applicable to the
                        target machine.
                        The <filename>deploy/images/<replaceable>machine</replaceable></filename>
                        directory can contain multiple bootloaders for the
                        machine.
                        </para></listitem>
                    <listitem><para>
                        <filename><replaceable>symlinks</replaceable></filename>:
                        The
                        <filename>deploy/images/<replaceable>machine</replaceable></filename>
                        folder contains a symbolic link that points to the
                        most recently built file for each machine.
                        These links might be useful for external scripts that
                        need to obtain the latest version of each file.
                        </para></listitem>
                </itemizedlist>
            </para>
        </section>

        <section id='sdk-dev-environment'>
            <title>Application Development SDK</title>

            <para>
                In the
                <link linkend='general-yocto-environment-figure'>general Yocto Project Development Environment figure</link>,
                the output labeled "Application Development SDK" represents an
                SDK.
                The SDK generation process differs depending on whether you
                build a standard SDK (e.g.
                <filename>bitbake -c populate_sdk</filename> <replaceable>imagename</replaceable>)
                or an extensible SDK (e.g.
                <filename>bitbake -c populate_sdk_ext</filename> <replaceable>imagename</replaceable>).
                This section is going to take a closer look at this output:
                <imagedata fileref="figures/sdk.png" align="center" width="9in" depth="7.25in" />
            </para>

            <para>
                The specific form of this output is a self-extracting
                SDK installer (<filename>*.sh</filename>) that, when run,
                installs the SDK, which consists of a cross-development
                toolchain, a set of libraries and headers, and an SDK
                environment setup script.
                Running this installer essentially sets up your
                cross-development environment.
                You can think of the cross-toolchain as the "host"
                part because it runs on the SDK machine.
                You can think of the libraries and headers as the "target"
                part because they are built for the target hardware.
                The environment setup script is added so that you can
                initialize the environment before using the tools.
            </para>

            <note><title>Notes</title>
                <itemizedlist>
                    <listitem><para>
                        The Yocto Project supports several methods by which
                        you can set up this cross-development environment.
                        These methods include downloading pre-built SDK
                        installers or building and installing your own SDK
                        installer.
                        </para></listitem>
                    <listitem><para>
                        For background information on cross-development
                        toolchains in the Yocto Project development
                        environment, see the
                        "<link linkend='cross-development-toolchain-generation'>Cross-Development Toolchain Generation</link>"
                        section.
                        </para></listitem>
                    <listitem><para>
                        For information on setting up a cross-development
                        environment, see the
                        <ulink url='&YOCTO_DOCS_SDK_URL;'>Yocto Project Application Development and the Extensible Software Development Kit (eSDK)</ulink>
                        manual.
                        </para></listitem>
                </itemizedlist>
            </note>

            <para>
                Once built, the SDK installers are written out to the
                <filename>deploy/sdk</filename> folder inside the
                <ulink url='&YOCTO_DOCS_REF_URL;#build-directory'>Build Directory</ulink>
                as shown in the figure at the beginning of this section.
                Depending on the type of SDK, several variables exist that help
                configure these files.
                The following list shows the variables associated with
                a standard SDK:
                <itemizedlist>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-DEPLOY_DIR'><filename>DEPLOY_DIR</filename></ulink>:
                        Points to the <filename>deploy</filename>
                        directory.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SDKMACHINE'><filename>SDKMACHINE</filename></ulink>:
                        Specifies the architecture of the machine
                        on which the cross-development tools are run to
                        create packages for the target hardware.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SDKIMAGE_FEATURES'><filename>SDKIMAGE_FEATURES</filename></ulink>:
                        Lists the features to include in the "target" part
                        of the SDK.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-TOOLCHAIN_HOST_TASK'><filename>TOOLCHAIN_HOST_TASK</filename></ulink>:
                        Lists packages that make up the host
                        part of the SDK (i.e. the part that runs on
                        the <filename>SDKMACHINE</filename>).
                        When you use
                        <filename>bitbake -c populate_sdk <replaceable>imagename</replaceable></filename>
                        to create the SDK, a set of default packages
                        apply.
                        This variable allows you to add more packages.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-TOOLCHAIN_TARGET_TASK'><filename>TOOLCHAIN_TARGET_TASK</filename></ulink>:
                        Lists packages that make up the target part
                        of the SDK (i.e. the part built for the
                        target hardware).
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SDKPATH'><filename>SDKPATH</filename></ulink>:
                        Defines the default SDK installation path offered
                        by the installation script.
                        </para></listitem>
                </itemizedlist>
                This next list, shows the variables associated with an
                extensible SDK:
                <itemizedlist>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-DEPLOY_DIR'><filename>DEPLOY_DIR</filename></ulink>:
                        Points to the <filename>deploy</filename> directory.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SDK_EXT_TYPE'><filename>SDK_EXT_TYPE</filename></ulink>:
                        Controls whether or not shared state artifacts are
                        copied into the extensible SDK.
                        By default, all required shared state artifacts are
                        copied into the SDK.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SDK_INCLUDE_PKGDATA'><filename>SDK_INCLUDE_PKGDATA</filename></ulink>:
                        Specifies whether or not packagedata will be
                        included in the extensible SDK for all recipes in
                        the "world" target.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SDK_INCLUDE_TOOLCHAIN'><filename>SDK_INCLUDE_TOOLCHAIN</filename></ulink>:
                        Specifies whether or not the toolchain will be included
                        when building the extensible SDK.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SDK_LOCAL_CONF_WHITELIST'><filename>SDK_LOCAL_CONF_WHITELIST</filename></ulink>:
                        A list of variables allowed through from the build
                        system configuration into the extensible SDK
                        configuration.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SDK_LOCAL_CONF_BLACKLIST'><filename>SDK_LOCAL_CONF_BLACKLIST</filename></ulink>:
                        A list of variables not allowed through from the build
                        system configuration into the extensible SDK
                        configuration.
                        </para></listitem>
                    <listitem><para>
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-SDK_INHERIT_BLACKLIST'><filename>SDK_INHERIT_BLACKLIST</filename></ulink>:
                        A list of classes to remove from the
                        <ulink url='&YOCTO_DOCS_REF_URL;#var-INHERIT'><filename>INHERIT</filename></ulink>
                        value globally within the extensible SDK configuration.
                        </para></listitem>
                </itemizedlist>
            </para>
        </section>
    </section>

    <section id="cross-development-toolchain-generation">
        <title>Cross-Development Toolchain Generation</title>

        <para>
            The Yocto Project does most of the work for you when it comes to
            creating
            <ulink url='&YOCTO_DOCS_REF_URL;#cross-development-toolchain'>cross-development toolchains</ulink>.
            This section provides some technical background on how
            cross-development toolchains are created and used.
            For more information on toolchains, you can also see the
            <ulink url='&YOCTO_DOCS_SDK_URL;'>Yocto Project Application Development and the Extensible Software Development Kit (eSDK)</ulink>
            manual.
        </para>

        <para>
            In the Yocto Project development environment, cross-development
            toolchains are used to build the image and applications that run
            on the target hardware.
            With just a few commands, the OpenEmbedded build system creates
            these necessary toolchains for you.
        </para>

        <para>
            The following figure shows a high-level build environment regarding
            toolchain construction and use.
        </para>

        <para>
            <imagedata fileref="figures/cross-development-toolchains.png" width="8in" depth="6in" align="center" />
        </para>

        <para>
            Most of the work occurs on the Build Host.
            This is the machine used to build images and generally work within
            the the Yocto Project environment.
            When you run
            <ulink url='&YOCTO_DOCS_REF_URL;#bitbake-term'>BitBake</ulink>
            to create an image, the OpenEmbedded build system
            uses the host <filename>gcc</filename> compiler to bootstrap a
            cross-compiler named <filename>gcc-cross</filename>.
            The <filename>gcc-cross</filename> compiler is what BitBake uses to
            compile source files when creating the target image.
            You can think of <filename>gcc-cross</filename> simply as an
            automatically generated cross-compiler that is used internally
            within BitBake only.
            <note>
                The extensible SDK does not use
                <filename>gcc-cross-canadian</filename> since this SDK
                ships a copy of the OpenEmbedded build system and the sysroot
                within it contains <filename>gcc-cross</filename>.
            </note>
        </para>

        <para>
            The chain of events that occurs when <filename>gcc-cross</filename> is
            bootstrapped is as follows:
            <literallayout class='monospaced'>
     gcc -> binutils-cross -> gcc-cross-initial -> linux-libc-headers -> glibc-initial -> glibc -> gcc-cross -> gcc-runtime
            </literallayout>
            <itemizedlist>
                <listitem><para>
                    <filename>gcc</filename>:
                    The build host's GNU Compiler Collection (GCC).
                    </para></listitem>
                <listitem><para>
                    <filename>binutils-cross</filename>:
                    The bare minimum binary utilities needed in order to run
                    the <filename>gcc-cross-initial</filename> phase of the
                    bootstrap operation.
                    </para></listitem>
                <listitem><para>
                    <filename>gcc-cross-initial</filename>:
                    An early stage of the bootstrap process for creating
                    the cross-compiler.
                    This stage builds enough of the <filename>gcc-cross</filename>,
                    the C library, and other pieces needed to finish building the
                    final cross-compiler in later stages.
                    This tool is a "native" package (i.e. it is designed to run on
                    the build host).
                    </para></listitem>
                <listitem><para>
                    <filename>linux-libc-headers</filename>:
                    Headers needed for the cross-compiler.
                    </para></listitem>
                <listitem><para>
                    <filename>glibc-initial</filename>:
                    An initial version of the Embedded GLIBC needed to bootstrap
                    <filename>glibc</filename>.
                    </para></listitem>
                <listitem><para>
                    <filename>gcc-cross</filename>:
                    The final stage of the bootstrap process for the
                    cross-compiler.
                    This stage results in the actual cross-compiler that
                    BitBake uses when it builds an image for a targeted
                    device.
                    <note>
                        If you are replacing this cross compiler toolchain
                        with a custom version, you must replace
                        <filename>gcc-cross</filename>.
                    </note>
                    This tool is also a "native" package (i.e. it is
                    designed to run on the build host).
                    </para></listitem>
                <listitem><para>
                    <filename>gcc-runtime</filename>:
                    Runtime libraries resulting from the toolchain bootstrapping
                    process.
                    This tool produces a binary that consists of the
                    runtime libraries need for the targeted device.
                    </para></listitem>
            </itemizedlist>
        </para>

        <para>
            You can use the OpenEmbedded build system to build an installer for
            the relocatable SDK used to develop applications.
            When you run the installer, it installs the toolchain, which
            contains the development tools (e.g.,
            <filename>gcc-cross-canadian</filename>,
            <filename>binutils-cross-canadian</filename>, and other
            <filename>nativesdk-*</filename> tools),
            which are tools native to the SDK (i.e. native to
            <ulink url='&YOCTO_DOCS_REF_URL;#var-SDK_ARCH'><filename>SDK_ARCH</filename></ulink>),
            you need to cross-compile and test your software.
            The figure shows the commands you use to easily build out this
            toolchain.
            This cross-development toolchain is built to execute on the
            <ulink url='&YOCTO_DOCS_REF_URL;#var-SDKMACHINE'><filename>SDKMACHINE</filename></ulink>,
            which might or might not be the same
            machine as the Build Host.
            <note>
                If your target architecture is supported by the Yocto Project,
                you can take advantage of pre-built images that ship with the
                Yocto Project and already contain cross-development toolchain
                installers.
            </note>
        </para>

        <para>
            Here is the bootstrap process for the relocatable toolchain:
            <literallayout class='monospaced'>
     gcc -> binutils-crosssdk -> gcc-crosssdk-initial -> linux-libc-headers ->
        glibc-initial -> nativesdk-glibc -> gcc-crosssdk -> gcc-cross-canadian
            </literallayout>
            <itemizedlist>
                <listitem><para>
                    <filename>gcc</filename>:
                    The build host's GNU Compiler Collection (GCC).
                    </para></listitem>
                <listitem><para>
                    <filename>binutils-crosssdk</filename>:
                    The bare minimum binary utilities needed in order to run
                    the <filename>gcc-crosssdk-initial</filename> phase of the
                    bootstrap operation.
                    </para></listitem>
                <listitem><para>
                    <filename>gcc-crosssdk-initial</filename>:
                    An early stage of the bootstrap process for creating
                    the cross-compiler.
                    This stage builds enough of the
                    <filename>gcc-crosssdk</filename> and supporting pieces so that
                    the final stage of the bootstrap process can produce the
                    finished cross-compiler.
                    This tool is a "native" binary that runs on the build host.
                    </para></listitem>
                <listitem><para>
                    <filename>linux-libc-headers</filename>:
                    Headers needed for the cross-compiler.
                    </para></listitem>
                <listitem><para>
                    <filename>glibc-initial</filename>:
                    An initial version of the Embedded GLIBC needed to bootstrap
                    <filename>nativesdk-glibc</filename>.
                    </para></listitem>
                <listitem><para>
                    <filename>nativesdk-glibc</filename>:
                    The Embedded GLIBC needed to bootstrap the
                    <filename>gcc-crosssdk</filename>.
                    </para></listitem>
                <listitem><para>
                    <filename>gcc-crosssdk</filename>:
                    The final stage of the bootstrap process for the
                    relocatable cross-compiler.
                    The <filename>gcc-crosssdk</filename> is a transitory compiler
                    and never leaves the build host.
                    Its purpose is to help in the bootstrap process to create the
                    eventual relocatable <filename>gcc-cross-canadian</filename>
                    compiler, which is relocatable.
                    This tool is also a "native" package (i.e. it is
                    designed to run on the build host).
                    </para></listitem>
                <listitem><para>
                    <filename>gcc-cross-canadian</filename>:
                    The final relocatable cross-compiler.
                    When run on the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-SDKMACHINE'><filename>SDKMACHINE</filename></ulink>,
                    this tool
                    produces executable code that runs on the target device.
                    Only one cross-canadian compiler is produced per architecture
                    since they can be targeted at different processor optimizations
                    using configurations passed to the compiler through the
                    compile commands.
                    This circumvents the need for multiple compilers and thus
                    reduces the size of the toolchains.
                    </para></listitem>
            </itemizedlist>
        </para>

        <note>
            For information on advantages gained when building a
            cross-development toolchain installer, see the
            "<ulink url='&YOCTO_DOCS_SDK_URL;#sdk-building-an-sdk-installer'>Building an SDK Installer</ulink>"
            section in the Yocto Project Application Development and the
            Extensible Software Development Kit (eSDK) manual.
        </note>
    </section>

    <section id="shared-state-cache">
        <title>Shared State Cache</title>

        <para>
            By design, the OpenEmbedded build system builds everything from
            scratch unless
            <ulink url='&YOCTO_DOCS_REF_URL;#bitbake-term'>BitBake</ulink>
            can determine that parts do not need to be rebuilt.
            Fundamentally, building from scratch is attractive as it means all
            parts are built fresh and there is no possibility of stale data
            causing problems.
            When developers hit problems, they typically default back to
            building from scratch so they know the state of things from the
            start.
        </para>

        <para>
            Building an image from scratch is both an advantage and a
            disadvantage to the process.
            As mentioned in the previous paragraph, building from scratch
            ensures that everything is current and starts from a known state.
            However, building from scratch also takes much longer as it
            generally means rebuilding things that do not necessarily need
            to be rebuilt.
        </para>

        <para>
            The Yocto Project implements shared state code that supports
            incremental builds.
            The implementation of the shared state code answers the following
            questions that were fundamental roadblocks within the OpenEmbedded
            incremental build support system:
            <itemizedlist>
                <listitem><para>
                    What pieces of the system have changed and what pieces have
                    not changed?
                    </para></listitem>
                <listitem><para>
                    How are changed pieces of software removed and replaced?
                    </para></listitem>
                <listitem><para>
                    How are pre-built components that do not need to be rebuilt
                    from scratch used when they are available?
                    </para></listitem>
            </itemizedlist>
        </para>

        <para>
            For the first question, the
            <ulink url='&YOCTO_DOCS_REF_URL;#build-system-term'>OpenEmbedded build system</ulink>
            detects changes in the "inputs" to a given task by creating a
            checksum (or signature) of the task's inputs.
            If the checksum changes, the system assumes the inputs have changed
            and the task needs to be rerun.
            For the second question, the shared state (sstate) code tracks
            which tasks add which output to the build process.
            This means the output from a given task can be removed, upgraded
            or otherwise manipulated.
            The third question is partly addressed by the solution for the
            second question assuming the build system can fetch the sstate
            objects from remote locations and install them if they are deemed
            to be valid.
            <note>
                The OpenEmbedded build system does not maintain
                <ulink url='&YOCTO_DOCS_REF_URL;#var-PR'><filename>PR</filename></ulink>
                information as part of the shared state packages.
                Consequently, considerations exist that affect maintaining
                shared state feeds.
                For information on how the OpenEmbedded build system
                works with packages and can track incrementing
                <filename>PR</filename> information, see the
                "<ulink url='&YOCTO_DOCS_DEV_URL;#automatically-incrementing-a-binary-package-revision-number'>Automatically Incrementing a Binary Package Revision Number</ulink>"
                section in the Yocto Project Development Tasks Manual.
            </note>
        </para>

        <para>
            The rest of this section goes into detail about the overall
            incremental build architecture, the checksums (signatures), shared
            state, and some tips and tricks.
        </para>

        <section id='concepts-overall-architecture'>
            <title>Overall Architecture</title>

            <para>
                When determining what parts of the system need to be built,
                BitBake works on a per-task basis rather than a per-recipe
                basis.
                You might wonder why using a per-task basis is preferred over
                a per-recipe basis.
                To help explain, consider having the IPK packaging backend
                enabled and then switching to DEB.
                In this case, the
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-install'><filename>do_install</filename></ulink>
                and
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package'><filename>do_package</filename></ulink>
                task outputs are still valid.
                However, with a per-recipe approach, the build would not
                include the <filename>.deb</filename> files.
                Consequently, you would have to invalidate the whole build and
                rerun it.
                Rerunning everything is not the best solution.
                Also, in this case, the core must be "taught" much about
                specific tasks.
                This methodology does not scale well and does not allow users
                to easily add new tasks in layers or as external recipes
                without touching the packaged-staging core.
            </para>
        </section>

        <section id='overview-checksums'>
            <title>Checksums (Signatures)</title>

            <para>
                The shared state code uses a checksum, which is a unique
                signature of a task's inputs, to determine if a task needs to
                be run again.
                Because it is a change in a task's inputs that triggers a
                rerun, the process needs to detect all the inputs to a given
                task.
                For shell tasks, this turns out to be fairly easy because
                the build process generates a "run" shell script for each task
                and it is possible to create a checksum that gives you a good
                idea of when the task's data changes.
            </para>

            <para>
                To complicate the problem, there are things that should not be
                included in the checksum.
                First, there is the actual specific build path of a given
                task - the
                <ulink url='&YOCTO_DOCS_REF_URL;#var-WORKDIR'><filename>WORKDIR</filename></ulink>.
                It does not matter if the work directory changes because it
                should not affect the output for target packages.
                Also, the build process has the objective of making native
                or cross packages relocatable.
                <note>
                    Both native and cross packages run on the
                    <ulink url='&YOCTO_DOCS_REF_URL;#hardware-build-system-term'>build host</ulink>.
                    However, cross packages generate output for the target
                    architecture.
                </note>
                The checksum therefore needs to exclude
                <filename>WORKDIR</filename>.
                The simplistic approach for excluding the work directory is to
                set <filename>WORKDIR</filename> to some fixed value and
                create the checksum for the "run" script.
            </para>

            <para>
                Another problem results from the "run" scripts containing
                functions that might or might not get called.
                The incremental build solution contains code that figures out
                dependencies between shell functions.
                This code is used to prune the "run" scripts down to the
                minimum set, thereby alleviating this problem and making the
                "run" scripts much more readable as a bonus.
            </para>

            <para>
                So far, solutions for shell scripts exist.
                What about Python tasks?
                The same approach applies even though these tasks are more
                difficult.
                The process needs to figure out what variables a Python
                function accesses and what functions it calls.
                Again, the incremental build solution contains code that first
                figures out the variable and function dependencies, and then
                creates a checksum for the data used as the input to the task.
            </para>

            <para>
                Like the <filename>WORKDIR</filename> case, situations exist
                where dependencies should be ignored.
                For these situations, you can instruct the build process to
                ignore a dependency by using a line like the following:
                <literallayout class='monospaced'>
     PACKAGE_ARCHS[vardepsexclude] = "MACHINE"
                </literallayout>
                This example ensures that the
                <ulink url='&YOCTO_DOCS_REF_URL;#var-PACKAGE_ARCHS'><filename>PACKAGE_ARCHS</filename></ulink>
                variable does not depend on the value of
                <ulink url='&YOCTO_DOCS_REF_URL;#var-MACHINE'><filename>MACHINE</filename></ulink>,
                even if it does reference it.
            </para>

            <para>
                Equally, there are cases where you need to add dependencies
                BitBake is not able to find.
                You can accomplish this by using a line like the following:
                <literallayout class='monospaced'>
      PACKAGE_ARCHS[vardeps] = "MACHINE"
                </literallayout>
                This example explicitly adds the <filename>MACHINE</filename>
                variable as a dependency for
                <filename>PACKAGE_ARCHS</filename>.
            </para>

            <para>
                As an example, consider a case with in-line Python where
                BitBake is not able to figure out dependencies.
                When running in debug mode (i.e. using
                <filename>-DDD</filename>), BitBake produces output when it
                discovers something for which it cannot figure out dependencies.
                The Yocto Project team has currently not managed to cover
                those dependencies in detail and is aware of the need to fix
                this situation.
            </para>

            <para>
                Thus far, this section has limited discussion to the direct
                inputs into a task.
                Information based on direct inputs is referred to as the
                "basehash" in the code.
                However, there is still the question of a task's indirect
                inputs - the things that were already built and present in the
                <ulink url='&YOCTO_DOCS_REF_URL;#build-directory'>Build Directory</ulink>.
                The checksum (or signature) for a particular task needs to add
                the hashes of all the tasks on which the particular task
                depends.
                Choosing which dependencies to add is a policy decision.
                However, the effect is to generate a master checksum that
                combines the basehash and the hashes of the task's
                dependencies.
            </para>

            <para>
                At the code level, a variety of ways exist by which both the
                basehash and the dependent task hashes can be influenced.
                Within the BitBake configuration file, you can give BitBake
                some extra information to help it construct the basehash.
                The following statement effectively results in a list of
                global variable dependency excludes - variables never
                included in any checksum:
                <literallayout class='monospaced'>
     BB_HASHBASE_WHITELIST ?= "TMPDIR FILE PATH PWD BB_TASKHASH BBPATH DL_DIR \
         SSTATE_DIR THISDIR FILESEXTRAPATHS FILE_DIRNAME HOME LOGNAME SHELL TERM \
         USER FILESPATH STAGING_DIR_HOST STAGING_DIR_TARGET COREBASE PRSERV_HOST \
         PRSERV_DUMPDIR PRSERV_DUMPFILE PRSERV_LOCKDOWN PARALLEL_MAKE \
         CCACHE_DIR EXTERNAL_TOOLCHAIN CCACHE CCACHE_DISABLE LICENSE_PATH SDKPKGSUFFIX"
                </literallayout>
                The previous example excludes
                <ulink url='&YOCTO_DOCS_REF_URL;#var-WORKDIR'><filename>WORKDIR</filename></ulink>
                since that variable is actually constructed as a path within
                <ulink url='&YOCTO_DOCS_REF_URL;#var-TMPDIR'><filename>TMPDIR</filename></ulink>,
                which is on the whitelist.
            </para>

            <para>
                The rules for deciding which hashes of dependent tasks to
                include through dependency chains are more complex and are
                generally accomplished with a Python function.
                The code in <filename>meta/lib/oe/sstatesig.py</filename> shows
                two examples of this and also illustrates how you can insert
                your own policy into the system if so desired.
                This file defines the two basic signature generators
                <ulink url='&YOCTO_DOCS_REF_URL;#oe-core'>OE-Core</ulink>
                uses:  "OEBasic" and "OEBasicHash".
                By default, there is a dummy "noop" signature handler enabled
                in BitBake.
                This means that behavior is unchanged from previous versions.
                OE-Core uses the "OEBasicHash" signature handler by default
                through this setting in the <filename>bitbake.conf</filename>
                file:
                <literallayout class='monospaced'>
     BB_SIGNATURE_HANDLER ?= "OEBasicHash"
                </literallayout>
                The "OEBasicHash" <filename>BB_SIGNATURE_HANDLER</filename>
                is the same as the "OEBasic" version but adds the task hash to
                the stamp files.
                This results in any
                <ulink url='&YOCTO_DOCS_REF_URL;#metadata'>Metadata</ulink>
                change that changes the task hash, automatically
                causing the task to be run again.
                This removes the need to bump
                <ulink url='&YOCTO_DOCS_REF_URL;#var-PR'><filename>PR</filename></ulink>
                values, and changes to Metadata automatically ripple across
                the build.
            </para>

            <para>
                It is also worth noting that the end result of these
                signature generators is to make some dependency and hash
                information available to the build.
                This information includes:
                <itemizedlist>
                    <listitem><para>
                        <filename>BB_BASEHASH_task-</filename><replaceable>taskname</replaceable>:
                        The base hashes for each task in the recipe.
                        </para></listitem>
                    <listitem><para>
                        <filename>BB_BASEHASH_</filename><replaceable>filename</replaceable><filename>:</filename><replaceable>taskname</replaceable>:
                        The base hashes for each dependent task.
                        </para></listitem>
                    <listitem><para>
                        <filename>BBHASHDEPS_</filename><replaceable>filename</replaceable><filename>:</filename><replaceable>taskname</replaceable>:
                        The task dependencies for each task.
                        </para></listitem>
                    <listitem><para>
                        <filename>BB_TASKHASH</filename>:
                        The hash of the currently running task.
                        </para></listitem>
                </itemizedlist>
            </para>
        </section>

        <section id='shared-state'>
            <title>Shared State</title>

            <para>
                Checksums and dependencies, as discussed in the previous
                section, solve half the problem of supporting a shared state.
                The other part of the problem is being able to use checksum
                information during the build and being able to reuse or rebuild
                specific components.
            </para>

            <para>
                The
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-classes-sstate'><filename>sstate</filename></ulink>
                class is a relatively generic implementation of how to
                "capture" a snapshot of a given task.
                The idea is that the build process does not care about the
                source of a task's output.
                Output could be freshly built or it could be downloaded and
                unpacked from somewhere - the build process does not need to
                worry about its origin.
            </para>

            <para>
                Two types of output exist.
                One type is just about creating a directory in
                <ulink url='&YOCTO_DOCS_REF_URL;#var-WORKDIR'><filename>WORKDIR</filename></ulink>.
                A good example is the output of either
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-install'><filename>do_install</filename></ulink>
                or
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package'><filename>do_package</filename></ulink>.
                The other type of output occurs when a set of data is merged
                into a shared directory tree such as the sysroot.
            </para>

            <para>
                The Yocto Project team has tried to keep the details of the
                implementation hidden in <filename>sstate</filename> class.
                From a user's perspective, adding shared state wrapping to a task
                is as simple as this
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-deploy'><filename>do_deploy</filename></ulink>
                example taken from the
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-classes-deploy'><filename>deploy</filename></ulink>
                class:
                <literallayout class='monospaced'>
     DEPLOYDIR = "${WORKDIR}/deploy-${PN}"
     SSTATETASKS += "do_deploy"
     do_deploy[sstate-inputdirs] = "${DEPLOYDIR}"
     do_deploy[sstate-outputdirs] = "${DEPLOY_DIR_IMAGE}"

     python do_deploy_setscene () {
         sstate_setscene(d)
     }
     addtask do_deploy_setscene
     do_deploy[dirs] = "${DEPLOYDIR} ${B}"
                </literallayout>
                The following list explains the previous example:
                <itemizedlist>
                    <listitem><para>
                        Adding "do_deploy" to <filename>SSTATETASKS</filename>
                        adds some required sstate-related processing, which is
                        implemented in the
                        <ulink url='&YOCTO_DOCS_REF_URL;#ref-classes-sstate'><filename>sstate</filename></ulink>
                        class, to before and after the
                        <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-deploy'><filename>do_deploy</filename></ulink>
                        task.
                        </para></listitem>
                    <listitem><para>
                        The
                        <filename>do_deploy[sstate-inputdirs] = "${DEPLOYDIR}"</filename>
                        declares that <filename>do_deploy</filename> places its
                        output in <filename>${DEPLOYDIR}</filename> when run
                        normally (i.e. when not using the sstate cache).
                        This output becomes the input to the shared state cache.
                        </para></listitem>
                    <listitem><para>
                        The
                        <filename>do_deploy[sstate-outputdirs] = "${DEPLOY_DIR_IMAGE}"</filename>
                        line causes the contents of the shared state cache to be
                        copied to <filename>${DEPLOY_DIR_IMAGE}</filename>.
                        <note>
                            If <filename>do_deploy</filename> is not already in
                            the shared state cache or if its input checksum
                            (signature) has changed from when the output was
                            cached, the task will be run to populate the shared
                            state cache, after which the contents of the shared
                            state cache is copied to
                            <filename>${DEPLOY_DIR_IMAGE}</filename>.
                            If <filename>do_deploy</filename> is in the shared
                            state cache and its signature indicates that the
                            cached output is still valid (i.e. if no
                            relevant task inputs have changed), then the
                            contents of the shared state cache will be copied
                            directly to
                            <filename>${DEPLOY_DIR_IMAGE}</filename> by the
                            <filename>do_deploy_setscene</filename> task
                            instead, skipping the
                            <filename>do_deploy</filename> task.
                        </note>
                        </para></listitem>
                    <listitem><para>
                        The following task definition is glue logic needed to
                        make the previous settings effective:
                        <literallayout class='monospaced'>
     python do_deploy_setscene () {
         sstate_setscene(d)
     }
     addtask do_deploy_setscene
                        </literallayout>
                        <filename>sstate_setscene()</filename> takes the flags
                        above as input and accelerates the
                        <filename>do_deploy</filename> task through the
                        shared state cache if possible.
                        If the task was accelerated,
                        <filename>sstate_setscene()</filename> returns True.
                        Otherwise, it returns False, and the normal
                        <filename>do_deploy</filename> task runs.
                        For more information, see the
                        "<ulink url='&YOCTO_DOCS_BB_URL;#setscene'>setscene</ulink>"
                        section in the BitBake User Manual.
                        </para></listitem>
                    <listitem><para>
                        The <filename>do_deploy[dirs] = "${DEPLOYDIR} ${B}"</filename>
                        line creates <filename>${DEPLOYDIR}</filename> and
                        <filename>${B}</filename> before the
                        <filename>do_deploy</filename> task runs, and also sets
                        the current working directory of
                        <filename>do_deploy</filename> to
                        <filename>${B}</filename>.
                        For more information, see the
                        "<ulink url='&YOCTO_DOCS_BB_URL;#variable-flags'>Variable Flags</ulink>"
                        section in the BitBake User Manual.
                        <note>
                            In cases where
                            <filename>sstate-inputdirs</filename> and
                            <filename>sstate-outputdirs</filename> would be the
                            same, you can use
                            <filename>sstate-plaindirs</filename>.
                            For example, to preserve the
                            <filename>${PKGD}</filename> and
                            <filename>${PKGDEST}</filename> output from the
                            <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package'><filename>do_package</filename></ulink>
                            task, use the following:
                            <literallayout class='monospaced'>
     do_package[sstate-plaindirs] = "${PKGD} ${PKGDEST}"
                            </literallayout>
                        </note>
                        </para></listitem>
                    <listitem><para>
                        <filename>sstate-inputdirs</filename> and
                        <filename>sstate-outputdirs</filename> can also be used
                        with multiple directories.
                        For example, the following declares
                        <filename>PKGDESTWORK</filename> and
                        <filename>SHLIBWORK</filename> as shared state
                        input directories, which populates the shared state
                        cache, and <filename>PKGDATA_DIR</filename> and
                        <filename>SHLIBSDIR</filename> as the corresponding
                        shared state output directories:
                        <literallayout class='monospaced'>
     do_package[sstate-inputdirs] = "${PKGDESTWORK} ${SHLIBSWORKDIR}"
     do_package[sstate-outputdirs] = "${PKGDATA_DIR} ${SHLIBSDIR}"
                        </literallayout>
                        </para></listitem>
                    <listitem><para>
                        These methods also include the ability to take a
                        lockfile when manipulating shared state directory
                        structures, for cases where file additions or removals
                        are sensitive:
                        <literallayout class='monospaced'>
     do_package[sstate-lockfile] = "${PACKAGELOCK}"
                        </literallayout>
                        </para></listitem>
                </itemizedlist>
            </para>

            <para>
                Behind the scenes, the shared state code works by looking in
                <ulink url='&YOCTO_DOCS_REF_URL;#var-SSTATE_DIR'><filename>SSTATE_DIR</filename></ulink>
                and
                <ulink url='&YOCTO_DOCS_REF_URL;#var-SSTATE_MIRRORS'><filename>SSTATE_MIRRORS</filename></ulink>
                for shared state files.
                Here is an example:
                <literallayout class='monospaced'>
     SSTATE_MIRRORS ?= "\
     file://.* http://someserver.tld/share/sstate/PATH;downloadfilename=PATH \n \
     file://.* file:///some/local/dir/sstate/PATH"
                </literallayout>
                <note>
                    The shared state directory
                    (<filename>SSTATE_DIR</filename>) is organized into
                    two-character subdirectories, where the subdirectory
                    names are based on the first two characters of the hash.
                    If the shared state directory structure for a mirror has the
                    same structure as <filename>SSTATE_DIR</filename>, you must
                    specify "PATH" as part of the URI to enable the build system
                    to map to the appropriate subdirectory.
                </note>
            </para>

            <para>
                The shared state package validity can be detected just by
                looking at the filename since the filename contains the task
                checksum (or signature) as described earlier in this section.
                If a valid shared state package is found, the build process
                downloads it and uses it to accelerate the task.
            </para>

            <para>
                The build processes use the <filename>*_setscene</filename>
                tasks for the task acceleration phase.
                BitBake goes through this phase before the main execution
                code and tries to accelerate any tasks for which it can find
                shared state packages.
                If a shared state package for a task is available, the
                shared state package is used.
                This means the task and any tasks on which it is dependent
                are not executed.
            </para>

            <para>
                As a real world example, the aim is when building an IPK-based
                image, only the
                <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package_write_ipk'><filename>do_package_write_ipk</filename></ulink>
                tasks would have their shared state packages fetched and
                extracted.
                Since the sysroot is not used, it would never get extracted.
                This is another reason why a task-based approach is preferred
                over a recipe-based approach, which would have to install the
                output from every task.n
            </para>
        </section>

        <section id='concepts-tips-and-tricks'>
            <title>Tips and Tricks</title>

            <para>
                The code in the build system that supports incremental builds
                is not simple code.
                This section presents some tips and tricks that help you work
                around issues related to shared state code.
            </para>

            <section id='concepts-overview-debugging'>
                <title>Debugging</title>

                <para>
                    Seeing what metadata went into creating the input signature
                    of a shared state (sstate) task can be a useful debugging
                    aid.
                    This information is available in signature information
                    (<filename>siginfo</filename>) files in
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-SSTATE_DIR'><filename>SSTATE_DIR</filename></ulink>.
                    For information on how to view and interpret information in
                    <filename>siginfo</filename> files, see the
                    "<ulink url='&YOCTO_DOCS_DEV_URL;#dev-viewing-task-variable-dependencies'>Viewing Task Variable Dependencies</ulink>"
                    section in the Yocto Project Development Tasks Manual.
                </para>
            </section>

            <section id='concepts-invalidating-shared-state'>
                <title>Invalidating Shared State</title>

                <para>
                    The OpenEmbedded build system uses checksums and shared
                    state cache to avoid unnecessarily rebuilding tasks.
                    Collectively, this scheme is known as "shared state code."
                </para>

                <para>
                    As with all schemes, this one has some drawbacks.
                    It is possible that you could make implicit changes to your
                    code that the checksum calculations do not take into
                    account.
                    These implicit changes affect a task's output but do not
                    trigger the shared state code into rebuilding a recipe.
                    Consider an example during which a tool changes its output.
                    Assume that the output of <filename>rpmdeps</filename>
                    changes.
                    The result of the change should be that all the
                    <filename>package</filename> and
                    <filename>package_write_rpm</filename> shared state cache
                    items become invalid.
                    However, because the change to the output is
                    external to the code and therefore implicit,
                    the associated shared state cache items do not become
                    invalidated.
                    In this case, the build process uses the cached items
                    rather than running the task again.
                    Obviously, these types of implicit changes can cause
                    problems.
                </para>

                <para>
                    To avoid these problems during the build, you need to
                    understand the effects of any changes you make.
                    Realize that changes you make directly to a function
                    are automatically factored into the checksum calculation.
                    Thus, these explicit changes invalidate the associated
                    area of shared state cache.
                    However, you need to be aware of any implicit changes that
                    are not obvious changes to the code and could affect
                    the output of a given task.
                </para>

                <para>
                    When you identify an implicit change, you can easily
                    take steps to invalidate the cache and force the tasks
                    to run.
                    The steps you can take are as simple as changing a
                    function's comments in the source code.
                    For example, to invalidate package shared state files,
                    change the comment statements of
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package'><filename>do_package</filename></ulink>
                    or the comments of one of the functions it calls.
                    Even though the change is purely cosmetic, it causes the
                    checksum to be recalculated and forces the OpenEmbedded
                    build system to run the task again.
                    <note>
                        For an example of a commit that makes a cosmetic
                        change to invalidate shared state, see this
                        <ulink url='&YOCTO_GIT_URL;/cgit.cgi/poky/commit/meta/classes/package.bbclass?id=737f8bbb4f27b4837047cb9b4fbfe01dfde36d54'>commit</ulink>.
                    </note>
                </para>
            </section>
        </section>
    </section>

    <section id='automatically-added-runtime-dependencies'>
        <title>Automatically Added Runtime Dependencies</title>

        <para>
            The OpenEmbedded build system automatically adds common types of
            runtime dependencies between packages, which means that you do not
            need to explicitly declare the packages using
            <ulink url='&YOCTO_DOCS_REF_URL;#var-RDEPENDS'><filename>RDEPENDS</filename></ulink>.
            Three automatic mechanisms exist (<filename>shlibdeps</filename>,
            <filename>pcdeps</filename>, and <filename>depchains</filename>)
            that handle shared libraries, package configuration (pkg-config)
            modules, and <filename>-dev</filename> and
            <filename>-dbg</filename> packages, respectively.
            For other types of runtime dependencies, you must manually declare
            the dependencies.
            <itemizedlist>
                <listitem><para>
                    <filename>shlibdeps</filename>:
                    During the
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package'><filename>do_package</filename></ulink>
                    task of each recipe, all shared libraries installed by the
                    recipe are located.
                    For each shared library, the package that contains the
                    shared library is registered as providing the shared
                    library.
                    More specifically, the package is registered as providing
                    the
                    <ulink url='https://en.wikipedia.org/wiki/Soname'>soname</ulink>
                    of the library.
                    The resulting shared-library-to-package mapping
                    is saved globally in
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-PKGDATA_DIR'><filename>PKGDATA_DIR</filename></ulink>
                    by the
                    <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-packagedata'><filename>do_packagedata</filename></ulink>
                    task.</para>

                    <para>Simultaneously, all executables and shared libraries
                    installed by the recipe are inspected to see what shared
                    libraries they link against.
                    For each shared library dependency that is found,
                    <filename>PKGDATA_DIR</filename> is queried to
                    see if some package (likely from a different recipe)
                    contains the shared library.
                    If such a package is found, a runtime dependency is added
                    from the package that depends on the shared library to the
                    package that contains the library.</para>

                    <para>The automatically added runtime dependency also
                    includes a version restriction.
                    This version restriction specifies that at least the
                    current version of the package that provides the shared
                    library must be used, as if
                    "<replaceable>package</replaceable> (>= <replaceable>version</replaceable>)"
                    had been added to <filename>RDEPENDS</filename>.
                    This forces an upgrade of the package containing the shared
                    library when installing the package that depends on the
                    library, if needed.</para>

                    <para>If you want to avoid a package being registered as
                    providing a particular shared library (e.g. because the library
                    is for internal use only), then add the library to
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-PRIVATE_LIBS'><filename>PRIVATE_LIBS</filename></ulink>
                    inside the package's recipe.
                    </para></listitem>
                <listitem><para>
                    <filename>pcdeps</filename>:
                    During the <filename>do_package</filename> task of each
                    recipe, all pkg-config modules
                    (<filename>*.pc</filename> files) installed by the recipe
                    are located.
                    For each module, the package that contains the module is
                    registered as providing the module.
                    The resulting module-to-package mapping is saved globally in
                    <filename>PKGDATA_DIR</filename> by the
                    <filename>do_packagedata</filename> task.</para>

                    <para>Simultaneously, all pkg-config modules installed by
                    the recipe are inspected to see what other pkg-config
                    modules they depend on.
                    A module is seen as depending on another module if it
                    contains a "Requires:" line that specifies the other module.
                    For each module dependency,
                    <filename>PKGDATA_DIR</filename> is queried to see if some
                    package contains the module.
                    If such a package is found, a runtime dependency is added
                    from the package that depends on the module to the package
                    that contains the module.
                    <note>
                        The <filename>pcdeps</filename> mechanism most often
                        infers dependencies between <filename>-dev</filename>
                        packages.
                    </note>
                    </para></listitem>
                <listitem><para>
                    <filename>depchains</filename>:
                    If a package <filename>foo</filename> depends on a package
                    <filename>bar</filename>, then <filename>foo-dev</filename>
                    and <filename>foo-dbg</filename> are also made to depend on
                    <filename>bar-dev</filename> and
                    <filename>bar-dbg</filename>, respectively.
                    Taking the <filename>-dev</filename> packages as an
                    example, the <filename>bar-dev</filename> package might
                    provide headers and shared library symlinks needed by
                    <filename>foo-dev</filename>, which shows the need
                    for a dependency between the packages.</para>

                    <para>The dependencies added by
                    <filename>depchains</filename> are in the form of
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-RRECOMMENDS'><filename>RRECOMMENDS</filename></ulink>.
                    <note>
                        By default, <filename>foo-dev</filename> also has an
                        <filename>RDEPENDS</filename>-style dependency on
                        <filename>foo</filename>, because the default value of
                        <filename>RDEPENDS_${PN}-dev</filename> (set in
                        <filename>bitbake.conf</filename>) includes
                        "${PN}".
                    </note></para>

                    <para>To ensure that the dependency chain is never broken,
                    <filename>-dev</filename> and <filename>-dbg</filename>
                    packages are always generated by default, even if the
                    packages turn out to be empty.
                    See the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-ALLOW_EMPTY'><filename>ALLOW_EMPTY</filename></ulink>
                    variable for more information.
                    </para></listitem>
            </itemizedlist>
        </para>

        <para>
            The <filename>do_package</filename> task depends on the
            <filename>do_packagedata</filename> task of each recipe in
            <ulink url='&YOCTO_DOCS_REF_URL;#var-DEPENDS'><filename>DEPENDS</filename></ulink>
            through use of a
            <filename>[</filename><ulink url='&YOCTO_DOCS_BB_URL;#variable-flags'><filename>deptask</filename></ulink><filename>]</filename>
            declaration, which guarantees that the required
            shared-library/module-to-package mapping information will be available
            when needed as long as <filename>DEPENDS</filename> has been
            correctly set.
        </para>
    </section>

    <section id='fakeroot-and-pseudo'>
        <title>Fakeroot and Pseudo</title>

        <para>
            Some tasks are easier to implement when allowed to perform certain
            operations that are normally reserved for the root user (e.g.
            <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-install'><filename>do_install</filename></ulink>,
            <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-package_write_deb'><filename>do_package_write*</filename></ulink>,
            <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-rootfs'><filename>do_rootfs</filename></ulink>,
            and
            <ulink url='&YOCTO_DOCS_REF_URL;#ref-tasks-image'><filename>do_image*</filename></ulink>).
            For example, the <filename>do_install</filename> task benefits
            from being able to set the UID and GID of installed files to
            arbitrary values.
        </para>

        <para>
            One approach to allowing tasks to perform root-only operations
            would be to require
            <ulink url='&YOCTO_DOCS_REF_URL;#bitbake-term'>BitBake</ulink>
            to run as root.
            However, this method is cumbersome and has security issues.
            The approach that is actually used is to run tasks that benefit
            from root privileges in a "fake" root environment.
            Within this environment, the task and its child processes believe
            that they are running as the root user, and see an internally
            consistent view of the filesystem.
            As long as generating the final output (e.g. a package or an image)
            does not require root privileges, the fact that some earlier
            steps ran in a fake root environment does not cause problems.
        </para>

        <para>
            The capability to run tasks in a fake root environment is known as
            "<ulink url='http://man.he.net/man1/fakeroot'>fakeroot</ulink>",
            which is derived from the BitBake keyword/variable
            flag that requests a fake root environment for a task.
        </para>

        <para>
            In the
            <ulink url='&YOCTO_DOCS_REF_URL;#build-system-term'>OpenEmbedded build system</ulink>,
            the program that implements fakeroot is known as Pseudo.
            Pseudo overrides system calls by using the environment variable
            <filename>LD_PRELOAD</filename>, which results in the illusion
            of running as root.
            To keep track of "fake" file ownership and permissions resulting
            from operations that require root permissions, Pseudo uses
            an SQLite 3 database.
            This database is stored in
            <filename>${</filename><ulink url='&YOCTO_DOCS_REF_URL;#var-WORKDIR'><filename>WORKDIR</filename></ulink><filename>}/pseudo/files.db</filename>
            for individual recipes.
            Storing the database in a file as opposed to in memory
            gives persistence between tasks and builds, which is not
            accomplished using fakeroot.
            <note><title>Caution</title>
                If you add your own task that manipulates the same files or
                directories as a fakeroot task, then that task also needs to
                run under fakeroot.
                Otherwise, the task cannot run root-only operations, and
                cannot see the fake file ownership and permissions set by the
                other task.
                You need to also add a dependency on
                <filename>virtual/fakeroot-native:do_populate_sysroot</filename>,
                giving the following:
                <literallayout class='monospaced'>
       fakeroot do_mytask () {
           ...
       }
       do_mytask[depends] += "virtual/fakeroot-native:do_populate_sysroot"
                </literallayout>
            </note>
            For more information, see the
            <ulink url='&YOCTO_DOCS_BB_URL;#var-FAKEROOT'><filename>FAKEROOT*</filename></ulink>
            variables in the BitBake User Manual.
            You can also reference the
            "<ulink url='http://www.ibm.com/developerworks/opensource/library/os-aapseudo1/index.html'>Pseudo</ulink>"
            and
            "<ulink url='https://github.com/wrpseudo/pseudo/wiki/WhyNotFakeroot'>Why Not Fakeroot?</ulink>"
            articles for background information on Pseudo.
        </para>
    </section>

    <section id="wayland">
        <title>Wayland</title>

        <para>
            <ulink url='http://en.wikipedia.org/wiki/Wayland_(display_server_protocol)'>Wayland</ulink>
            is a computer display server protocol that
            provides a method for compositing window managers to communicate
            directly with applications and video hardware and expects them to
            communicate with input hardware using other libraries.
            Using Wayland with supporting targets can result in better control
            over graphics frame rendering than an application might otherwise
            achieve.
        </para>

        <para>
            The Yocto Project provides the Wayland protocol libraries and the
            reference
            <ulink url='http://en.wikipedia.org/wiki/Wayland_(display_server_protocol)#Weston'>Weston</ulink>
            compositor as part of its release.
            This section describes what you need to do to implement Wayland and
            use the compositor when building an image for a supporting target.
        </para>

        <section id="wayland-support">
            <title>Support</title>

            <para>
                The Wayland protocol libraries and the reference Weston
                compositor ship as integrated packages in the
                <filename>meta</filename> layer of the
                <ulink url='&YOCTO_DOCS_REF_URL;#source-directory'>Source Directory</ulink>.
                Specifically, you can find the recipes that build both Wayland
                and Weston at
                <filename>meta/recipes-graphics/wayland</filename>.
            </para>

            <para>
                You can build both the Wayland and Weston packages for use only
                with targets that accept the
                <ulink url='https://en.wikipedia.org/wiki/Mesa_(computer_graphics)'>Mesa 3D and Direct Rendering Infrastructure</ulink>,
                which is also known as Mesa DRI.
                This implies that you cannot build and use the packages if your
                target uses, for example, the
                <trademark class='registered'>Intel</trademark> Embedded Media
                and Graphics Driver
                (<trademark class='registered'>Intel</trademark> EMGD) that
                overrides Mesa DRI.
                <note>
                    Due to lack of EGL support, Weston 1.0.3 will not run
                    directly on the emulated QEMU hardware.
                    However, this version of Weston will run under X emulation
                    without issues.
                </note>
            </para>
        </section>

        <section id="enabling-wayland-in-an-image">
            <title>Enabling Wayland in an Image</title>

            <para>
                To enable Wayland, you need to enable it to be built and enable
                it to be included in the image.
            </para>

            <section id="enable-building">
                <title>Building</title>

                <para>
                    To cause Mesa to build the <filename>wayland-egl</filename>
                    platform and Weston to build Wayland with Kernel Mode
                    Setting
                    (<ulink url='https://wiki.archlinux.org/index.php/Kernel_Mode_Setting'>KMS</ulink>)
                    support, include the "wayland" flag in the
                    <ulink url="&YOCTO_DOCS_REF_URL;#var-DISTRO_FEATURES"><filename>DISTRO_FEATURES</filename></ulink>
                    statement in your <filename>local.conf</filename> file:
                    <literallayout class='monospaced'>
     DISTRO_FEATURES_append = " wayland"
                    </literallayout>
                    <note>
                        If X11 has been enabled elsewhere, Weston will build
                        Wayland with X11 support
                    </note>
                </para>
            </section>

            <section id="enable-installation-in-an-image">
                <title>Installing</title>

                <para>
                    To install the Wayland feature into an image, you must
                    include the following
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-CORE_IMAGE_EXTRA_INSTALL'><filename>CORE_IMAGE_EXTRA_INSTALL</filename></ulink>
                    statement in your <filename>local.conf</filename> file:
                    <literallayout class='monospaced'>
     CORE_IMAGE_EXTRA_INSTALL += "wayland weston"
                    </literallayout>
                </para>
            </section>
        </section>

        <section id="running-weston">
            <title>Running Weston</title>

            <para>
                To run Weston inside X11, enabling it as described earlier and
                building a Sato image is sufficient.
                If you are running your image under Sato, a Weston Launcher
                appears in the "Utility" category.
            </para>

            <para>
                Alternatively, you can run Weston through the command-line
                interpretor (CLI), which is better suited for development work.
                To run Weston under the CLI, you need to do the following after
                your image is built:
                <orderedlist>
                    <listitem><para>
                        Run these commands to export
                        <filename>XDG_RUNTIME_DIR</filename>:
                        <literallayout class='monospaced'>
     mkdir -p /tmp/$USER-weston
     chmod 0700 /tmp/$USER-weston
     export XDG_RUNTIME_DIR=/tmp/$USER-weston
                        </literallayout>
                        </para></listitem>
                    <listitem><para>
                        Launch Weston in the shell:
                        <literallayout class='monospaced'>
     weston
                        </literallayout></para></listitem>
                </orderedlist>
            </para>
        </section>
    </section>

    <section id="overview-licenses">
        <title>Licenses</title>

        <para>
            This section describes the mechanism by which the
            <ulink url='&YOCTO_DOCS_REF_URL;#build-system-term'>OpenEmbedded build system</ulink>
            tracks changes to licensing text.
            The section also describes how to enable commercially licensed
            recipes, which by default are disabled.
        </para>

        <para>
            For information that can help you maintain compliance with
            various open source licensing during the lifecycle of the product,
            see the
            "<ulink url='&YOCTO_DOCS_DEV_URL;#maintaining-open-source-license-compliance-during-your-products-lifecycle'>Maintaining Open Source License Compliance During Your Project's Lifecycle</ulink>"
            section in the Yocto Project Development Tasks Manual.
        </para>

        <section id="usingpoky-configuring-LIC_FILES_CHKSUM">
            <title>Tracking License Changes</title>

            <para>
                The license of an upstream project might change in the future.
                In order to prevent these changes going unnoticed, the
                <ulink url='&YOCTO_DOCS_REF_URL;#var-LIC_FILES_CHKSUM'><filename>LIC_FILES_CHKSUM</filename></ulink>
                variable tracks changes to the license text. The checksums are
                validated at the end of the configure step, and if the
                checksums do not match, the build will fail.
            </para>

            <section id="usingpoky-specifying-LIC_FILES_CHKSUM">
                <title>Specifying the <filename>LIC_FILES_CHKSUM</filename> Variable</title>

                <para>
                    The <filename>LIC_FILES_CHKSUM</filename>
                    variable contains checksums of the license text in the
                    source code for the recipe.
                    Following is an example of how to specify
                    <filename>LIC_FILES_CHKSUM</filename>:
                    <literallayout class='monospaced'>
     LIC_FILES_CHKSUM = "file://COPYING;md5=xxxx \
                         file://licfile1.txt;beginline=5;endline=29;md5=yyyy \
                         file://licfile2.txt;endline=50;md5=zzzz \
                         ..."
                    </literallayout>
                    <note><title>Notes</title>
                        <itemizedlist>
                            <listitem><para>
                                When using "beginline" and "endline", realize
                                that line numbering begins with one and not
                                zero.
                                Also, the included lines are inclusive (i.e.
                                lines five through and including 29 in the
                                previous example for
                                <filename>licfile1.txt</filename>).
                                </para></listitem>
                            <listitem><para>
                                When a license check fails, the selected license
                                text is included as part of the QA message.
                                Using this output, you can determine the exact
                                start and finish for the needed license text.
                                </para></listitem>
                        </itemizedlist>
                    </note>
                </para>

                <para>
                    The build system uses the
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-S'><filename>S</filename></ulink>
                    variable as the default directory when searching files
                    listed in <filename>LIC_FILES_CHKSUM</filename>.
                    The previous example employs the default directory.
                </para>

                <para>
                    Consider this next example:
                    <literallayout class='monospaced'>
     LIC_FILES_CHKSUM = "file://src/ls.c;beginline=5;endline=16;\
                                         md5=bb14ed3c4cda583abc85401304b5cd4e"
     LIC_FILES_CHKSUM = "file://${WORKDIR}/license.html;md5=5c94767cedb5d6987c902ac850ded2c6"
                    </literallayout>
                </para>

                <para>
                    The first line locates a file in
                    <filename>${S}/src/ls.c</filename> and isolates lines five
                    through 16 as license text.
                    The second line refers to a file in
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-WORKDIR'><filename>WORKDIR</filename></ulink>.
                </para>

                <para>
                    Note that <filename>LIC_FILES_CHKSUM</filename> variable is
                    mandatory for all recipes, unless the
                    <filename>LICENSE</filename> variable is set to "CLOSED".
                </para>
            </section>

            <section id="usingpoky-LIC_FILES_CHKSUM-explanation-of-syntax">
                <title>Explanation of Syntax</title>

                <para>
                    As mentioned in the previous section, the
                    <filename>LIC_FILES_CHKSUM</filename> variable lists all
                    the important files that contain the license text for the
                    source code.
                    It is possible to specify a checksum for an entire file,
                    or a specific section of a file (specified by beginning and
                    ending line numbers with the "beginline" and "endline"
                    parameters, respectively).
                    The latter is useful for source files with a license
                    notice header, README documents, and so forth.
                    If you do not use the "beginline" parameter, then it is
                    assumed that the text begins on the first line of the file.
                    Similarly, if you do not use the "endline" parameter,
                    it is assumed that the license text ends with the last
                    line of the file.
                </para>

                <para>
                    The "md5" parameter stores the md5 checksum of the license
                    text.
                    If the license text changes in any way as compared to
                    this parameter then a mismatch occurs.
                    This mismatch triggers a build failure and notifies
                    the developer.
                    Notification allows the developer to review and address
                    the license text changes.
                    Also note that if a mismatch occurs during the build,
                    the correct md5 checksum is placed in the build log and
                    can be easily copied to the recipe.
                </para>

                <para>
                    There is no limit to how many files you can specify using
                    the <filename>LIC_FILES_CHKSUM</filename> variable.
                    Generally, however, every project requires a few
                    specifications for license tracking.
                    Many projects have a "COPYING" file that stores the
                    license information for all the source code files.
                    This practice allows you to just track the "COPYING"
                    file as long as it is kept up to date.
                    <note><title>Tips</title>
                        <itemizedlist>
                            <listitem><para>
                                If you specify an empty or invalid "md5"
                                parameter,
                                <ulink url='&YOCTO_DOCS_REF_URL;#bitbake-term'>BitBake</ulink>
                                returns an md5 mis-match
                                error and displays the correct "md5" parameter
                                value during the build.
                                The correct parameter is also captured in
                                the build log.
                                </para></listitem>
                            <listitem><para>
                                If the whole file contains only license text,
                                you do not need to use the "beginline" and
                               "endline" parameters.
                               </para></listitem>
                        </itemizedlist>
                    </note>
                </para>
            </section>
        </section>

        <section id="enabling-commercially-licensed-recipes">
            <title>Enabling Commercially Licensed Recipes</title>

            <para>
                By default, the OpenEmbedded build system disables
                components that have commercial or other special licensing
                requirements.
                Such requirements are defined on a
                recipe-by-recipe basis through the
                <ulink url='&YOCTO_DOCS_REF_URL;#var-LICENSE_FLAGS'><filename>LICENSE_FLAGS</filename></ulink>
                variable definition in the affected recipe.
                For instance, the
                <filename>poky/meta/recipes-multimedia/gstreamer/gst-plugins-ugly</filename>
                recipe contains the following statement:
                <literallayout class='monospaced'>
     LICENSE_FLAGS = "commercial"
                </literallayout>
                Here is a slightly more complicated example that contains both
                an explicit recipe name and version (after variable expansion):
                <literallayout class='monospaced'>
     LICENSE_FLAGS = "license_${PN}_${PV}"
                </literallayout>
	            In order for a component restricted by a
                <filename>LICENSE_FLAGS</filename> definition to be enabled and
                included in an image, it needs to have a matching entry in the
                global
	            <ulink url='&YOCTO_DOCS_REF_URL;#var-LICENSE_FLAGS_WHITELIST'><filename>LICENSE_FLAGS_WHITELIST</filename></ulink>
                variable, which is a variable typically defined in your
                <filename>local.conf</filename> file.
                For example, to enable the
                <filename>poky/meta/recipes-multimedia/gstreamer/gst-plugins-ugly</filename>
	            package, you could add either the string
	            "commercial_gst-plugins-ugly" or the more general string
	            "commercial" to <filename>LICENSE_FLAGS_WHITELIST</filename>.
                See the
                "<link linkend='license-flag-matching'>License Flag Matching</link>"
                section for a full
                explanation of how <filename>LICENSE_FLAGS</filename> matching
                works.
                Here is the example:
                <literallayout class='monospaced'>
     LICENSE_FLAGS_WHITELIST = "commercial_gst-plugins-ugly"
                </literallayout>
	            Likewise, to additionally enable the package built from the
                recipe containing
	            <filename>LICENSE_FLAGS = "license_${PN}_${PV}"</filename>,
                and assuming that the actual recipe name was
                <filename>emgd_1.10.bb</filename>, the following string would
                enable that package as well as the original
                <filename>gst-plugins-ugly</filename> package:
                <literallayout class='monospaced'>
     LICENSE_FLAGS_WHITELIST = "commercial_gst-plugins-ugly license_emgd_1.10"
                </literallayout>
	            As a convenience, you do not need to specify the complete
                license string in the whitelist for every package.
                You can use an abbreviated form, which consists
                of just the first portion or portions of the license
                string before the initial underscore character or characters.
                A partial string will match any license that contains the
                given string as the first portion of its license.
                For example, the following whitelist string will also match
                both of the packages previously mentioned as well as any other
                packages that have licenses starting with "commercial" or
                "license".
                <literallayout class='monospaced'>
     LICENSE_FLAGS_WHITELIST = "commercial license"
                </literallayout>
            </para>

            <section id="license-flag-matching">
                <title>License Flag Matching</title>

                <para>
		            License flag matching allows you to control what recipes
                    the OpenEmbedded build system includes in the build.
                    Fundamentally, the build system attempts to match
                    <filename>LICENSE_FLAGS</filename> strings found in recipes
                    against <filename>LICENSE_FLAGS_WHITELIST</filename>
                    strings found in the whitelist.
                    A match causes the build system to include a recipe in the
                    build, while failure to find a match causes the build
                    system to exclude a recipe.
                </para>

                <para>
                    In general, license flag matching is simple.
                    However, understanding some concepts will help you
                    correctly and effectively use matching.
                </para>

                <para>
                    Before a flag
                    defined by a particular recipe is tested against the
                    contents of the whitelist, the expanded string
                    <filename>_${PN}</filename> is appended to the flag.
                    This expansion makes each
                    <filename>LICENSE_FLAGS</filename> value recipe-specific.
                    After expansion, the string is then matched against the
                    whitelist.
                    Thus, specifying
                    <filename>LICENSE_FLAGS = "commercial"</filename>
                    in recipe "foo", for example, results in the string
                    <filename>"commercial_foo"</filename>.
                    And, to create a match, that string must appear in the
                    whitelist.
                </para>

                <para>
                    Judicious use of the <filename>LICENSE_FLAGS</filename>
                    strings and the contents of the
                    <filename>LICENSE_FLAGS_WHITELIST</filename> variable
                    allows you a lot of flexibility for including or excluding
                    recipes based on licensing.
                    For example, you can broaden the matching capabilities by
                    using license flags string subsets in the whitelist.
                    <note>
                        When using a string subset, be sure to use the part of
                        the expanded string that precedes the appended
                        underscore character (e.g.
                        <filename>usethispart_1.3</filename>,
                        <filename>usethispart_1.4</filename>, and so forth).
                    </note>
                    For example, simply specifying the string "commercial" in
                    the whitelist matches any expanded
                    <filename>LICENSE_FLAGS</filename> definition that starts
                    with the string "commercial" such as "commercial_foo" and
                    "commercial_bar", which are the strings the build system
                    automatically generates for hypothetical recipes named
                    "foo" and "bar" assuming those recipes simply specify the
                    following:
                    <literallayout class='monospaced'>
     LICENSE_FLAGS = "commercial"
                    </literallayout>
                    Thus, you can choose to exhaustively
                    enumerate each license flag in the whitelist and
                    allow only specific recipes into the image, or
                    you can use a string subset that causes a broader range of
                    matches to allow a range of recipes into the image.
                </para>

                <para>
                    This scheme works even if the
                    <filename>LICENSE_FLAGS</filename> string already
                    has <filename>_${PN}</filename> appended.
                    For example, the build system turns the license flag
                    "commercial_1.2_foo" into "commercial_1.2_foo_foo" and
                    would match both the general "commercial" and the specific
                    "commercial_1.2_foo" strings found in the whitelist, as
                    expected.
                </para>

                <para>
                    Here are some other scenarios:
                    <itemizedlist>
                        <listitem><para>
                            You can specify a versioned string in the recipe
                            such as "commercial_foo_1.2" in a "foo" recipe.
                            The build system expands this string to
                            "commercial_foo_1.2_foo".
                            Combine this license flag with a whitelist that has
                            the string "commercial" and you match the flag
                            along with any other flag that starts with the
                            string "commercial".
                            </para></listitem>
                        <listitem><para>
                            Under the same circumstances, you can use
                            "commercial_foo" in the whitelist and the build
                            system not only matches "commercial_foo_1.2" but
                            also matches any license flag with the string
                            "commercial_foo", regardless of the version.
                            </para></listitem>
                        <listitem><para>
                            You can be very specific and use both the
                            package and version parts in the whitelist (e.g.
                            "commercial_foo_1.2") to specifically match a
                            versioned recipe.
                            </para></listitem>
                    </itemizedlist>
                </para>
            </section>

            <section id="other-variables-related-to-commercial-licenses">
                <title>Other Variables Related to Commercial Licenses</title>

                <para>
                    Other helpful variables related to commercial
                    license handling exist and are defined in the
                    <filename>poky/meta/conf/distro/include/default-distrovars.inc</filename> file:
                    <literallayout class='monospaced'>
     COMMERCIAL_AUDIO_PLUGINS ?= ""
     COMMERCIAL_VIDEO_PLUGINS ?= ""
                    </literallayout>
                    If you want to enable these components, you can do so by
                    making sure you have statements similar to the following
                    in your <filename>local.conf</filename> configuration file:
                    <literallayout class='monospaced'>
     COMMERCIAL_AUDIO_PLUGINS = "gst-plugins-ugly-mad \
        gst-plugins-ugly-mpegaudioparse"
     COMMERCIAL_VIDEO_PLUGINS = "gst-plugins-ugly-mpeg2dec \
        gst-plugins-ugly-mpegstream gst-plugins-bad-mpegvideoparse"
     LICENSE_FLAGS_WHITELIST = "commercial_gst-plugins-ugly commercial_gst-plugins-bad commercial_qmmp"
                    </literallayout>
                    Of course, you could also create a matching whitelist
                    for those components using the more general "commercial"
                    in the whitelist, but that would also enable all the
                    other packages with <filename>LICENSE_FLAGS</filename>
                    containing "commercial", which you may or may not want:
                    <literallayout class='monospaced'>
     LICENSE_FLAGS_WHITELIST = "commercial"
                    </literallayout>
                </para>

                <para>
                    Specifying audio and video plug-ins as part of the
                    <filename>COMMERCIAL_AUDIO_PLUGINS</filename> and
                    <filename>COMMERCIAL_VIDEO_PLUGINS</filename> statements
                    (along with the enabling
                    <filename>LICENSE_FLAGS_WHITELIST</filename>) includes the
                    plug-ins or components into built images, thus adding
                    support for media formats or components.
                </para>
            </section>
        </section>
    </section>
</chapter>
<!--
vim: expandtab tw=80 ts=4
-->
